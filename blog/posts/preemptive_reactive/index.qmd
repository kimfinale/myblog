---
title: "To Wait or To Act? Optimizing Reactive vs. Pre-emptive Vaccination Strategies"
author: "Jong-Hoon Kim"
date: "2025-06-27"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
# Setup
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(gridExtra)
library(readxl)
library(ggpattern)
library(patchwork)
library(RColorBrewer)
library(xdvir)
library(data.table)
library(scales)
library(purrr)
library(plotly)
library(ggbrace)
# source("R/utils.R")
# Figure dimensions
figure_size <- data.table(
  journal = c("Lancet"),
  single = c(85),
  double = c(178)
)
fgw1 <- figure_size[journal == "Lancet", single]
fgw2 <- figure_size[journal == "Lancet", double]
save_plot <- FALSE
```

# Background

Preventing and controlling infectious disease outbreaks requires making
strategic use of limited vaccine stockpiles. This challenge is
especially acute for diseases such as cholera and typhoid fever, where
global supplies remain constrained and timely deployment is crucial. In
principle, directing vaccines toward high-risk populations should yield
the greatest benefit, but real-world uncertainty—in outbreak timing,
risk signals, and operational response—can make simple pro-rata
allocation surprisingly competitive.

Existing modeling studies typically assume that outbreaks will occur and
therefore evaluate strategies only conditional on an epidemic happening.
What remains unclear is how to choose between pre-emptive, reactive, or
mixed vaccination strategies when outbreaks are uncertain and when
economic constraints matter.

To address this gap, we developed a general analytical framework that
identifies the vaccination strategy minimizing total expected societal
cost, including both vaccination expenditures and potential outbreak
losses. Our approach integrates limited vaccine supply, heterogeneous
outbreak risks, targeting accuracy, and economic trade-offs.

Using a combination of closed-form analytical results and Monte Carlo
simulations, we characterize optimal allocation rules across a wide
range of operational settings. This framework provides practical,
quantitative guidance for policymakers designing vaccination strategies
under uncertainty.

# Economic costs of outbreaks and vaccination campaign

## Cost of an outbreak

1.  Direct medical costs

This component covers the cost of inpatient and outpatient care for all
cholera cases:

$$
C_{\text{illness}}^{\text{direct}}  = N_{\text{inpatient}}\times C_{\text{inpatient}} + N_{\text{outpatient}}\times C_{\text{outpatient}} .
$$

2.  Productivity loss due to illness

We estimate:

$$
C_{\text{illness}}^{\text{indirect}}= N_{\text{cases}}\times d \times w ,
$$

where

-   $d$: average number of workdays lost per case
-   $w$: average daily wage

3.  Productivity loss due to premature death

We compare two approaches:

-   **Approach 1: Human Capital (Present Value of Lost Income)**

$$
C_{\text{death}}^{\text{HC}} = D \times \sum_{t=1}^{YLL} \frac{G}{(1+r)^t}
$$

-   **Approach 2: Value of Statistical Life (VSL)**

$$
C_{\text{death}}^{VSL} = D \times V
$$

Where:

-   $D$: number of deaths
-   $YLL$: average years of productive life lost
-   $G$: GDP per capita
-   $r_{\text{discount}}$: discount rate (e.g., 0.03)
-   $V$: estimated value of statistical life (in USD)

The total outbreak cost or the cost from infection is

$$
C_{\text{outbreak}} = C_{\text{I}} = C_{\text{illness}}^{\text{direct}} + C_{\text{illness}}^{\text{indirect}} + C_{\text{death}}.
$$

## Cost of a Cholera Vaccination Program

We use:

$$
C_{\text{vaccination}} = C_{\text{V}} =N_{\text{people}}\times (c_{\text{dose}} + c_{\text{delivery}}),
$$

where $c_{\text{dose}}$ = vaccine cost per dose, $c_{\text{delivery}}$ =
delivery cost per dose.

# Scenarios

Let:

-   $p_i$ = outbreak probability for population $i$, $i = 1,\dots,n$,
-   $C_{\mathrm{I}}$ = outbreak cost arising from infections,
-   $C_{\mathrm{V}}$ = vaccination cost,
-   $r \in [0,1]$ = effectiveness of reactive vaccination,
-   $R = C_{\mathrm{I}}/C_{\mathrm{V}}$ = outbreak–to–vaccination cost
    ratio,
-   $f \in (0,1]$ = total vaccination capacity as a fraction of
    populations,
-   $\alpha \in [0,1]$ = fraction of vaccination capacity used
    pre-emptively,
-   $f_{\mathrm{pre}} = \alpha f$ = fraction of populations vaccinated
    pre-emptively,
-   $f_{\mathrm{react}} = (1-\alpha)f$ = vaccination capacity reserved
    for reactive campaigns.

## One Population

We consider a single population with outbreak probability $p$, outbreak
cost $C_{\mathrm{I}}$, vaccination cost $C_{\mathrm{V}}$, and reactive
vaccination effectiveness $r \in [0,1]$. The outbreak cost
$C_{\mathrm{I}}$ reflects direct medical costs, productivity losses, and
mortality-related losses. The vaccination cost $C_{\mathrm{V}}$ includes
vaccine and delivery costs.

Let $X \sim \mathrm{Bernoulli}(p)$ denote an indicator of an outbreak,
where $X=1$ if an outbreak occurs and $X=0$ otherwise.

### Pre-emptive strategy

Under pre-emptive vaccination, the population is vaccinated regardless
of whether an outbreak occurs. Any potential outbreak is fully averted,
so the total cost is deterministic:

$$
C_{\mathrm{pre}}(X) = C_{\mathrm{V}}.
$$

Thus,

$$
\mathbb{E}[C_{\mathrm{pre}}] = C_{\mathrm{V}}.
$$

### Reactive strategy

Under reactive vaccination, the population is vaccinated only if an
outbreak occurs. If $X=1$, the vaccination cost $C_{\mathrm{V}}$ is
incurred and residual outbreak costs equal $(1-r) C_{\mathrm{I}}$. If
$X=0$, there is no cost. The total cost random variable is:

$$
C_{\mathrm{react}}(X) = X\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr).
$$

Taking expectation,

$$
\mathbb{E}[C_{\mathrm{react}}]
= p\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr).
$$

This calculation assumes no penalty or loss from unused vaccine stock.
In practice, vaccine expiry or wastage may incur additional costs, but
these are omitted here for analytical clarity.

### Normalized Per-Population Expected Costs

Define the outbreak-to-vaccination cost ratio:

$$
R = \frac{C_{\mathrm{I}}}{C_{\mathrm{V}}}.
$$

Normalizing by $C_{\mathrm{V}}$:

#### Pre-emptive:

$$
c_{\mathrm{pre}}^{(1)}
= \frac{\mathbb{E}[C_{\mathrm{pre}}]}{C_{\mathrm{V}}}
= 1.
$$

#### Reactive:

$$
c_{\mathrm{react}}^{(1)}
= \frac{\mathbb{E}[C_{\mathrm{react}}]}{C_{\mathrm{V}}}
= p\bigl[1 + (1-r)R\bigr].
$$

These represent the normalized per-population expected costs of the two
strategies with the superscript $(1)$ indicating one-population case.

### Threshold Outbreak Probability $p_{\mathrm{thr}}^{(1)}$

The threshold outbreak probability $p_{\mathrm{thr}}^{(1)}$ at which the two strategies
yield equal expected cost is given by:

$$
c_{\mathrm{pre}}^{(1)} = c_{\mathrm{react}}^{(1)}
\quad\Longrightarrow\quad
p_{\mathrm{thr}}^{(1)} = \frac{1}{1 + (1-r)R}.
$$

Interpretation:

-   **Pre-emptive preferred** when 
$$
    p > p_{\mathrm{thr}}^{(1)}
    \quad\Longleftrightarrow\quad
    c_{\mathrm{pre}}^{(1)} < c_{\mathrm{react}}^{(1)}.
$$

-   **Reactive preferred** when 
$$
    p < p_{\mathrm{thr}}^{(1)}
    \quad\Longleftrightarrow\quad
    c_{\mathrm{pre}}^{(1)} > c_{\mathrm{react}}^{(1)}.
$$
-   **Indifference point** 
$$
    p = p_{\mathrm{thr}}^{(1)}
    \quad\Longleftrightarrow\quad
    c_{\mathrm{pre}}^{(1)} = c_{\mathrm{react}}^{(1)}.
$$

The threshold $p_{\mathrm{thr}}^{(1)}$ decreases as the reactive effectiveness $r$
decreases or the outbreak cost ratio $R$ increases. Thus, pre-emptive
vaccination becomes more favorable when reactive vaccination is less effective or when outbreaks are relatively more costly.

### Visualization

#### Functions

```{r}
# Pre-emptive cost (normalized by C_V)
cost_pre_one <- function(p, R, r) {
  # p and r unused but kept for a consistent interface
  1
}

# Reactive cost (normalized by C_V)
cost_react_one <- function(p, R, r) {
  p * (1 + (1 - r) * R)
}

p_star_one <- function(R, r) {
  1 / (1 + (1 - r) * R)
}
```

#### Normalized per-population costs across $p$ for varying $r$.

In the figure below, $c_s^{(1)}$ denotes the normalized per-population
expected cost for strategy $s \in \{\mathrm{pre}, \mathrm{react}\}$.

Key insights are:
  1. The cost remains constant for the pre-emptive strategy whereas it increases with the outbreak probability $p$ for the reactive strategy.
  2. There is a threshold outbreak probability $p_{\mathrm{thr}}^{(1)}$ at which the costs of the pre-emptive and reactive strategies are equal, below which reactive vaccination is economically preferable.
  3. The threshold $p_{\mathrm{thr}}^{(1)}$ is higher for greater effectiveness of the reactive strategy, $r$.
  4. As long as vaccine-induced protection at the population level is maintained, the pre-emptive strategy becomes preferable over an extended period of duration as the overall probability of an outbreak would increase over time.

```{r}
# --- Parameters for the illustration ---
p_vals <- seq(0, 1, 0.01)       # mean outbreak probability
R_vals <- c(5)           
r_vals <-  c(0.3, 0.7)

df_cost <- expand.grid(
    p = p_vals, 
    r = r_vals, 
    R = R_vals
  ) |>
  dplyr::mutate(
    c_pre   = cost_pre_one(p, R, r),
    c_react = cost_react_one(p, R, r),
    r_label = paste0("italic(r)==", r)) |>
  tidyr::pivot_longer(
    cols      = c(c_pre, c_react),
    names_to  = "strategy",
    values_to = "cost"
  ) |>
  dplyr::mutate(
    strategy = factor(
      strategy,
      levels = c("c_pre", "c_react"),
      labels = c("Pre-emptive", "Reactive")
    )
  )

# threshold probability
# df_pstar <- expand.grid(r = r_vals, R = R_vals) |>
#   dplyr::mutate(
#     p_star  = p_star_one(R, r),
#     r_label = paste0("r = ", r)
#   )
df_pstar <- expand.grid(r = r_vals, R = R_vals) |>
  dplyr::mutate(
    p_star  = p_star_one(R, r),
    r_label = paste0("r = ", r),
    
    # [NEW] Create the dynamic label string here
    # ~ adds a space, italic(r)==r adds the value
    label_expr = paste0("italic(p)[thr]^(1) ~ (italic(r) == ", r, ")")
  )

# data for braces

cost_react_max1 <- max(filter(df_cost, strategy == "Reactive", r_label == "italic(r)==0.7")$cost)
cost_react_max2 <- max(filter(df_cost, strategy == "Reactive", r_label == "italic(r)==0.3")$cost)
df_brace1 <- data.frame(x=c(0.96,1), y=c(1,cost_react_max1))
df_brace2 <- data.frame(x=c(0.97,1), y=c(1,cost_react_max2))
df_brace3 <- data.frame(x=c(0,0.03), y=c(0,1))

# convenient variables for the overhead-cost text position
text_overhead_x <- max(df_brace3$x) + 0.01  # 0.04
text_overhead_y <- mean(df_brace3$y) + 1    # 1.5
annot_text_size <- 4

ggplot(df_cost, aes(x = p, y = cost, color = strategy, 
                    linetype = r_label)) +
  geom_line(linewidth = 1) +
  geom_vline(
    data = df_pstar,
    aes(xintercept = p_star),
    linetype = "dashed",
    color = "firebrick"
  )+
  geom_text(
    data = df_pstar,
    aes(x = p_star, y = Inf, label = label_expr),
    parse = TRUE,
    inherit.aes = FALSE,
    hjust = -0.03,
    vjust = 1.1,
    size  = 3
  ) +
  
  ggbrace::stat_brace(
    data = df_brace1,
    mapping = aes(x, y),
    outside = FALSE, rotate = 270, 
    linewidth = 1, inherit.aes = FALSE
  )+
  annotate("text", x = min(df_brace1$x)-0.01, 
           y = mean(df_brace1$y), 
           label = "Cost of delayed\nresponse (r=0.7)", 
           hjust = 1, size = annot_text_size, lineheight = 0.9) +
  ggbrace::stat_brace(
    data = df_brace2,
    mapping = aes(x, y),
    outside = FALSE, rotate = 270, 
    linewidth = 1, inherit.aes = FALSE
  )+
  annotate("text", x = min(df_brace2$x)-0.01, y = mean(df_brace2$y), 
           label =  "Cost of delayed\nresponse (r=0.3)", 
           hjust = 1, size = annot_text_size, lineheight = 0.9) +
  ggbrace::stat_brace(
    data = df_brace3,
    mapping = aes(x, y),
    outside = FALSE, rotate = 90, 
    linewidth = 1, inherit.aes = FALSE
  )+
  annotate("text", x = max(df_brace3$x)+0.01, 
           y= mean(df_brace3$y)+1, 
           label =  "Vaccination cost", 
           hjust = 0, size = annot_text_size, lineheight = 0.9) +
  annotate("segment", 
             x = text_overhead_x + 0.03,  
             y = text_overhead_y - 0.1, 
             xend = 0.02,  yend = 0.75, 
    arrow = arrow(length = grid::unit(0.15, "cm")),
    colour = "black"
  ) +
  scale_color_manual("", values=c("firebrick","steelblue"))+
  scale_linetype_discrete(labels = scales::label_parse())+
  labs(
    x = expression("Probability of an outbreak "~italic(p)),
    y = expression("Normalized per-population expected cost  " ~ italic(c)[s]^'(1)'),
    color = "",
    linetype = "")+
  theme_light() +
  theme(legend.position = "top")+
  guides(
    linetype = guide_legend(
      override.aes = list(color = "steelblue")
    )
  )
```

#### Phase diagram of $p$ vs $r$ for $R=1$.
```{r}
r_vals <- seq(0.01, 0.99, by = 0.01)
R_vals <- c(1, 10)

data <- expand.grid(r = r_vals, R = R_vals) %>%
  dplyr::mutate(
    pstar = p_star_one(R = R, r = r),
    R_label = factor(
      R,
      levels = c(1, 10),
      labels = c("R = 1", "R = 10")
    )
  )
# LaTeX labels for xdvir::geom_latex()
eq_labels <- c(
    "$c_{\\text{pre}}^{(1)} < c_{\\text{react}}^{(1)}$", 
    "$c_{\\text{pre}}^{(1)} > c_{\\text{react}}^{(1)}$")

pthr_labels <- c("$p_{\\text{thr}}^{(1)}(R=1)$",
                "$p_{\\text{thr}}^{(1)}(R=10)$")

plt <- ggplot(data, aes(x = r, y = pstar, linetype = R_label)) +
  geom_line()+
  # geom_abline(
  #   slope = 1, intercept = 0,
  #   linetype = "dotted",
  #   linewidth = 1,
  #   color = "firebrick"
  # ) +
  labs(
    x = expression("Reactive effectiveness " ~ italic(r)),
    y = expression("Outbreak probability  " ~ italic(p))
  ) +
  theme_light() +
  theme(legend.position = "top") +
  # Existing text labels
  annotate("text", size = 4, x = 0, y = 1,
           hjust = 0, vjust = 1,
           label = "Pre-emptive favored") +
  annotate("text", size = 4, x = 1, y = 0,
           hjust = 1, vjust = 0,
           label = "Reactive favored") +
  annotate(
    "latex",
    x = 0, y = 0.93,
    label = eq_labels[1],
    size = 4, hjust = 0, vjust = 1
  ) +
  annotate(
    "latex",
    x = 1, y = 0.07,
    label = eq_labels[2],
    size = 4, hjust = 1, vjust = 0
  ) +
  annotate(
    "latex",
    x = 0.62, y = 0.74,
    label = pthr_labels[1],
    size = 4, hjust = 1, vjust = 0
  )  +
  annotate(
    "latex",
    x = 0.62, y = 0.22,
    label = pthr_labels[2],
    size = 4, hjust = 1, vjust = 0
  ) +
  guides(linetype = "none")

plt
# ggsave("p_thr_1.pdf",
#          plt,
#          device = cairo_pdf, width = 70*2,
#          height = 50*2, units = "mm")
```

#### $p_{\mathrm{thr}}^{(1)}$ as a function of $R$ for $r=0.5$.

```{r}
r_vals <- c(0.3, 0.5, 0.7)
R_vals <- seq(0.1, 50, by=0.1)

data <- expand.grid(r = r_vals, R = R_vals) %>%
  dplyr::mutate(pstar = p_star_one(R=R, r=r))

ggplot(data, aes(x = R, y = pstar, color = factor(r))) +
  geom_line(linewidth = 1) +
  labs(x = expression("Cost ratio "~italic(R)),
       y = expression("Threshold outbreak probability  "~italic(p)[thr]^(1)), 
       color = expression(italic(r)))+
  theme_light()+
  theme(legend.position = "top")
```

#### $p_{\mathrm{thr}}^{(1)}$ as a function of $r$ for varying $R$'s

```{r}
r_vals <- seq(0.01, 0.99, by = 0.01)
R_vals <- c(0.1, 1, 10)

data <- expand.grid(r = r_vals, R = R_vals) %>%
  dplyr::mutate(pstar = p_star_one(r=r, R=R))

ggplot(data, aes(x = r, y = pstar, color = factor(R))) +
  geom_line(linewidth = 1) +
  geom_abline(slope=1, intercept = 0, linetype="dotted", 
              linewidth=1, color="firebrick")+
  labs(x = expression("Reactive effectiveness "~italic(r)),
       y = expression("Threshold outbreak probability  "~italic(p)[thr]^(1)),
       color = expression(italic(R))) +
  theme_light()+
  theme(legend.position = "top")
```

#### Heatmap of $p_{\mathrm{thr}}^{(1)}$ across $r$ and $R$

```{r}
# Grid over r and R
r_vals <- seq(0, 1, length.out = 100)
R_vals <- 10 ^ seq(-2, 2, length.out = 100)

# --- 2. Create Tidy Data for ggplot ---
# Instead of outer(), we use expand.grid() to get x, y, z columns
df_heatmap <- expand.grid(R = R_vals, r = r_vals) %>%
  mutate(p_val = p_star_one(R, r))

# --- 3. Create Label Data ---
# Locations to label regions (Pre-emptive vs Reactive)
df_labels <- data.frame(
  R   = c(10, 0.1),  # R_pre, R_reac
  r   = c(0.2, 0.9), # r_pre, r_reac
  lab = c("Pre-emptive\nregion", "Reactive\nregion")
)

# Compute the curve p_thr^(1)=0.5 ---
# For each r, find R such that p_star_one(R,r)=0.5
df_boundary <- lapply(r_vals, function(rr) {
  # Define function in R to solve
  f_root <- function(R) p_star_one(R, rr) - 0.5
  
  # Solve in log10(R) space for stability
  sol <- tryCatch(
    uniroot(f_root, interval = c(0.01, 100)),
    error = function(e) NULL
  )
  
  if (is.null(sol)) return(NULL)
  
  data.frame(
    r = rr,
    R = sol$root
  )
}) %>% bind_rows()

# Pick a midpoint location for annotation
i_mid <- round(nrow(df_boundary) / 2)
annot_R <- df_boundary$R[i_mid]
annot_r <- df_boundary$r[i_mid]

# --- 4. Plotting ---
ggplot(df_heatmap, aes(x = R, y = r)) +
  # Use geom_raster for heatmaps (faster/smoother than geom_tile for dense grids)
  geom_raster(aes(fill = p_val)) +
  # Add red boundary line
  geom_line(data = df_boundary, aes(x = R, y = r),
            color = "firebrick", linewidth=1) +
    # Add annotation for p=0.5
  annotate("text",
           x = annot_R,
           y = annot_r,
           label = expression(italic(p) == 0.5),
           color = "firebrick",
           size = 4,
           hjust = -0.2) +
  # # Add text labels for the regions
  # geom_text(data = df_labels, aes(label = lab), 
  #           color = "white", size = 4) +
  # Scales
  scale_x_log10(
    breaks = c(0.01, 0.1, 1, 10, 100),
    labels = c("0.01", "0.1", "1", "10", "100"),
    expand = c(0,0) # Removes whitespace at edges
  ) +
  scale_y_continuous(expand = c(0,0)) +
  # Colors (Viridis matches your original Plotly choice)
  scale_fill_viridis_c(
    option = "viridis",
    name = expression(italic(p)[thr]^(1)) # Mathematical expression for legend
  ) +
  # Labels and Theme
  labs(
    x = expression("Cost ratio "~italic(R) == italic(C)[I] / italic(C)[V]),
    y = expression("Reactive effectiveness  "~italic(r))
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(), # Heatmaps usually look better without grids
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.key.height = unit(1.5, "cm") # Make legend bar taller
  )
```  
### Key Insight

In a single population, the normalized per-population expected cost of
the pre-emptive strategy, $c_{\mathrm{pre}}^{(1)}$, remains at 1, while the reactive strategy cost
increases linearly with the outbreak probability $p$. Their intersection
defines the threshold $p_{\mathrm{thr}}^{(1)}$. Pre-emptive vaccination is favored when $r$
is low and $R$ is high. This analysis assumes no costs associated with
unused vaccines, a simplifying assumption that can be relaxed in more
detailed models.

## Multiple Populations with Equal Risk and Limited Vaccination Capacity

We now extend the model to $n$ independent populations, each with the
same outbreak probability $p$. The total vaccine stockpile is limited
and can cover only a fraction $0 < f \le 1$ of the
populations—equivalently, we can conduct $fn$ pre-emptive or reactive
vaccination campaigns in total. 

Importantly, we treat vaccination at the population level: each
population is either fully vaccinated or not vaccinated at all. We do
not consider scenarios where all populations receive reduced coverage;
instead, the capacity constraint applies solely to the number of
populations that can be vaccinated.

The superscript $(n)$ in $c_{\mathrm{pre}}^{(n)}$,
$c_{\mathrm{react}}^{(n)}$, and $c_{\mathrm{mixed}}^{(n)}$ indicates
that these are normalized per-population costs in the $n$-population
equal-risk setting. 

We first consider two benchmark strategies that both respect the
capacity constraint. We solve the model for large $n$ such that the proportion of the population that experience outbreaks is approximately $p$.

1.  Pure pre-emptive strategy

All $fn$ campaigns are used pre-emptively:

-   A fraction $f$ of populations is vaccinated pre-emptively and incurs
    cost $C_{\mathrm{V}}$ each.
-   The remaining fraction $(1 - f)$ is not vaccinated pre-emptively;
    each such population experiences an outbreak with probability $p$
    and, under a pure pre-emptive strategy, receives no reactive
    vaccination. Outbreaks in this group cost $C_{\mathrm{I}}$.

The per-population expected cost is

$$
C_{\mathrm{pre}}^{(n)}
= f C_{\mathrm{V}} + (1-f)\,p C_{\mathrm{I}}.
$$

Normalizing by $C_{\mathrm{V}}$ gives

$$
c_{\mathrm{pre}}^{(n)}
= \frac{C_{\mathrm{pre}}^{(n)}}{C_{\mathrm{V}}}
= f + (1-f)pR.
$$

2.  Pure reactive strategy

Under the pure reactive strategy, no population is vaccinated
pre-emptively, and all $fn$ campaigns are reserved for outbreak
response.

Two regimes arise:

1. Vaccine-rich reactive regime ($f \ge p$)

Capacity is sufficient to respond to essentially all outbreaks
($fn \ge pn$). For each population, with probability $p$, an outbreak occurs and is reactively vaccinated. The associated cost is $C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}$. With probability $(1-p)$, no outbreak occurs and no cost is incurred.

Thus

$$
C_{\mathrm{react}}^{(n)}
= p\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr), 
\qquad
c_{\mathrm{react}}^{(n)}
= p\bigl[1 + (1-r)R\bigr],
\quad\text{for } f \ge p.
$$

2. Vaccine-limited reactive regime ($f < p$):

On average there are more outbreaks than available campaigns
($pn > fn$). Assuming reactive campaigns are allocated uniformly at random among outbreaks, the fraction of outbreaks that receive a reactive campaign is $f/p$.

For a given population, with probability $p$, an outbreak occurs and conditional on outbreak, with probability $f/p$, reactive vaccination occurs. The associated cost is $C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}$. Also, conditional on outbreak, with probability $1 - f/p$, no campaign occurs and the associated cost is simply $C_{\mathrm{I}}$.

The per-population expected cost is

$$
\begin{aligned}
C_{\mathrm{react}}^{(n)}
&= p \left[
   \frac{f}{p}\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr)
   + \left(1 - \frac{f}{p}\right) C_{\mathrm{I}}
   \right] \\
&= f\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr)
   + (p-f) C_{\mathrm{I}} \\
&= f C_{\mathrm{V}} + \bigl[p - fr\bigr] C_{\mathrm{I}}.
\end{aligned}
$$
Normalizing,

$$
c_{\mathrm{react}}^{(n)}
= \frac{C_{\mathrm{react}}^{(n)}}{C_{\mathrm{V}}}
= f + \bigl[p - fr\bigr] R,
\qquad \text{for } f < p.
$$

We can summarize the pure reactive cost as

$$
c_{\mathrm{react}}^{(n)} =
\begin{cases}
f + (p - fr)R, & f < p,\\[6pt]
p\bigl[1 + (1-r)R\bigr], & f \ge p.
\end{cases}
$$

### Visualization

#### Functions

```{r}
cost_pre_multi <- function(p, R, r, f) {
  f + (1 - f) * p * R
}

cost_react_multi <- function(p, R, r, f) {
  ifelse(
    f < p,
    # reactive-limited
    f + (p - f * r) * R,
    # reactive-rich
    p * (1 + (1 - r) * R)
  )
}

cost_diff_multi <- function(p, R, r, f) {
  c_pre <- cost_pre_multi(p, R, r, f)
  c_react <- cost_react_multi(p, R, r, f)
  c_pre - c_react
}

p_star_multi <- function(R, r, f, tol = 1e-10) {
  # Candidate 1: reactive-limited regime (p > f): p* = r
  p_star_RL <- r
  valid_RL <- (p_star_RL > f) && (p_star_RL >= 0) && (p_star_RL <= 1)
  if (valid_RL) {
    diff_val <- cost_diff_multi(p_star_RL, R = R, r = r, f = f)
    if (abs(diff_val) < 1e-6) {
      return(p_star_RL)
    }
  }

  # Candidate 2: reactive-rich regime (p <= f)
  denom <- R * (r - f) - 1
  if (abs(denom) < tol) {
    p_star_RR <- NA_real_
  } else {
    p_star_RR <- -f / denom
  }

  valid_RR <- !is.na(p_star_RR) &&
    (p_star_RR >= 0) && (p_star_RR <= f) && (p_star_RR <= 1)

  if (valid_RR) {
    diff_val <- cost_diff_multi(p_star_RR, R = R, r = r, f = f)
    if (abs(diff_val) < 1e-6) {
      return(p_star_RR)
    }
  }

  # Fallback: numeric search
  p_grid <- seq(1e-6, 1 - 1e-6, length.out = 2001)
  vals <- cost_diff_multi(p_grid, R = R, r = r, f = f)
  idx <- which(vals[-1] * vals[-length(vals)] <= 0)
  if (length(idx) == 0) {
    return(NA_real_)
  }

  i <- idx[1]
  lower <- p_grid[i]
  upper <- p_grid[i + 1]

  uniroot(cost_diff_multi,
          lower = lower, upper = upper,
          R = R, r = r, f = f, tol = tol)$root
}
```

#### $c_{\mathrm{pre}}^{(n)}$ and $c_{\mathrm{react}}^{(n)}$

The normalzied per-population expected cost linearly increases with $f$ for the pre-emptive strategy whereas, in case of reactive strategy, it increases only up to a point where $f=p$ and then remains constant.

$p = 0.4, R = 1$.
```{r}
p_val  <- 0.4
R_val  <- 1
r_vals <- c(0.2, 0.4, 0.6)

f_grid <- seq(0, 1, by = 0.01)

df_cost <- expand.grid(
  f = f_grid,
  r = r_vals
) |>
  dplyr::mutate(
    c_pre   = cost_pre_multi(p = p_val, R = R_val, r = r, f = f),
    c_react = cost_react_multi(p = p_val, R = R_val, r = r, f = f),
    r_label = paste0("r = ", r)
  ) |>
  tidyr::pivot_longer(
    cols      = c(c_pre, c_react),
    names_to  = "strategy",
    values_to = "cost"
  ) |>
  dplyr::mutate(
    strategy = factor(
      strategy,
      levels = c("c_pre", "c_react"),
      labels = c("Pre-emptive", "Reactive")
    )
  )

ggplot(df_cost, aes(x = f, y = cost, color = strategy)) +
  geom_line(linewidth = 1) +
  geom_vline(
    xintercept = p_val,
    linetype   = "dashed",
    linewidth  = 0.8,
    color      = "black"
  ) +
  facet_wrap(~ r_label, nrow = 1) +
  labs(
    x = expression("Vaccinated fraction"~italic(f)),
    y = expression("Normalized per-population expected cost " ~ italic(c)[s]^'(n)'),
    color = ""
  ) +
  annotate(
    "text",
    x      = p_val,
    y      = max(df_cost$cost, na.rm = TRUE),
    label  = "f == p",
    parse  = TRUE,
    hjust  = -0.1,
    vjust  = 1.2,
    size   = 4
  ) +
  theme_light() +
  theme(
    legend.position = "top"
  )
```

$p = 0.4, R = 5$.
```{r}
p_val  <- 0.4
R_val  <- 5
r_vals <- c(0.2, 0.4, 0.6)

f_grid <- seq(0, 1, by = 0.01)

df_cost <- expand.grid(
  f = f_grid,
  r = r_vals
) |>
  dplyr::mutate(
    c_pre   = cost_pre_multi(p = p_val, R = R_val, r = r, f = f),
    c_react = cost_react_multi(p = p_val, R = R_val, r = r, f = f),
    r_label = paste0("r = ", r)
  ) |>
  tidyr::pivot_longer(
    cols      = c(c_pre, c_react),
    names_to  = "strategy",
    values_to = "cost"
  ) |>
  dplyr::mutate(
    strategy = factor(
      strategy,
      levels = c("c_pre", "c_react"),
      labels = c("Pre-emptive", "Reactive")
    )
  )

ggplot(df_cost, aes(x = f, y = cost, color = strategy)) +
  geom_line(linewidth = 1) +
  geom_vline(
    xintercept = p_val,
    linetype   = "dashed",
    linewidth  = 0.8,
    color      = "black"
  ) +
  facet_wrap(~ r_label, nrow = 1) +
  labs(
    x = expression("Vaccinated fraction"~italic(f)),
    y = expression("Normalized per-population expected cost " ~ italic(c)[s]^'(n)'),
    color = ""
  ) +
  annotate(
    "text",
    x      = p_val,
    y      = max(df_cost$cost, na.rm = TRUE),
    label  = "f == p",
    parse  = TRUE,
    hjust  = -0.1,
    vjust  = 1.2,
    size   = 4
  ) +
  theme_light() +
  theme(
    legend.position = "top"
  )
```

#### $p_{\mathrm{thr}}^{(n)}$ in case of multi-population of equal-risk for $f = 0.5$:

```{r}
r_vals  <- seq(0, 1, by = 0.005)
R_vals  <- c(0.1, 1, 10)
f_val   <- 0.5

df_multi <- expand.grid(r = r_vals, R = R_vals) |>
  dplyr::rowwise() |>
  dplyr::mutate(p_star = p_star_multi(R = R, r = r, f = f_val)) |>
  dplyr::ungroup()

ggplot(df_multi, aes(x = r, y = p_star, color = factor(R))) +
  geom_line(linewidth = 1) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dotted",
              linewidth = 1, color = "firebrick") +
  geom_abline(slope = 0, intercept = f_val,
              linetype = "dotted",
              linewidth = 1, color = "steelblue") +
  scale_y_continuous(limits = c(0, 1)) +
  labs(
    x = expression(italic(r)),
    y = expression(italic(p)[thr]^(italic(n))),
    color = expression(italic(R))
  ) +
  theme_light() +
  theme(legend.position = "top") +
  annotate("text", size = 5,
           x = 0, y = 1, hjust = 0, vjust = 1,
           label = "Pre-emptive") +
  annotate("text", size = 4,
           x = 1, y = 0, hjust = 1, vjust = 0,
           label = "Reactive")+
  annotate("text", size = 4,
           x = 1, y = f_val, hjust = 1, vjust = -0.3,
           label = expression(italic(f)))
```

#### Phase diagram of p vs r for multipop equal-risk, given f
```{r}
r_vals <- seq(0.01, 0.99, by = 0.01)
R_vals <- c(1, 10)

# Choose capacity fraction f (change as needed)
f_val <- 0.5

data <- expand.grid(r = r_vals, R = R_vals) %>%
  dplyr::mutate(
    pstar = mapply(
      function(R_i, r_i) p_star_multi(R = R_i, r = r_i, f = f_val),
      R, r
    ),
    R_label = factor(
      R,
      levels = c(1, 10),
      labels = c("R = 1", "R = 10")
    )
  )

# LaTeX labels for xdvir::geom_latex()
eq_labels <- c(
  "$c_{\\text{pre}}^{(n)} < c_{\\text{react}}^{(n)}$", 
  "$c_{\\text{pre}}^{(n)} > c_{\\text{react}}^{(n)}$"
)

# You can switch to (n) if you want to emphasize multipop: p_thr^{(n)}
pthr_labels <- c(
  "$p_{\\text{thr}}^{(n)}(R=1)$",
  "$p_{\\text{thr}}^{(n)}(R=10)$"
)

plt <- ggplot(data, aes(x = r, y = pstar, linetype = R_label)) +
  geom_line() +
  # geom_abline(
  #   slope = 1, intercept = 0,
  #   linetype = "dotted",
  #   linewidth = 1,
  #   color = "firebrick"
  # ) +
  labs(
    x = expression("Reactive effectiveness " ~ italic(r)),
    y = expression("Outbreak probability  " ~ italic(p))
  ) +
  theme_light() +
  theme(legend.position = "top") +
  # Existing text labels
  annotate("text", size = 4, x = 0, y = 1,
           hjust = 0, vjust = 1,
           label = "Pre-emptive favored") +
  annotate("text", size = 4, x = 1, y = 0,
           hjust = 1, vjust = 0,
           label = "Reactive favored") +
  annotate(
    "latex",
    x = 0, y = 0.93,
    label = eq_labels[1],
    size = 4, hjust = 0, vjust = 1
  ) +
  annotate(
    "latex",
    x = 1, y = 0.07,
    label = eq_labels[2],
    size = 4, hjust = 1, vjust = 0
  ) +
  annotate(
    "latex",
    x = 0.37, y = 0.45,
    label = pthr_labels[1],
    size = 4, hjust = 1, vjust = 0
  ) +
  annotate(
    "latex",
    x = 0.37, y = 0.22,
    label = pthr_labels[2],
    size = 4, hjust = 1, vjust = 0
  ) +
  guides(linetype = "none")

ggsave(
  "p_thr_multi_f03.pdf",
  plt,
  device = cairo_pdf,
  width = 70 * 2,
  height = 50 * 2,
  units = "mm"
)
```

#### 3d surface of $p_{\mathrm{thr}}^{(n)}$ across $R$ and $r$

```{r}
f_val <- 0.3

r_vals <- seq(0, 1, length.out = 100)
R_vals <- 10 ^ seq(-2, 2, length.out = 100)

p_mat_n <- outer(
  R_vals, r_vals,
  Vectorize(function(R, r) p_star_multi(R = R, r = r, f = f_val))
)

p_mat_n_t <- t(p_mat_n)

R_pre  <- 10
r_pre  <- 0.2
p_pre_star <- p_star_multi(R = R_pre, r = r_pre, f = f_val)
p_pre  <- min(1, p_pre_star + 0.6)

R_reac <- 10
r_reac <- 0.8
p_reac_star <- p_star_multi(R = R_reac, r = r_reac, f = f_val)
p_reac <- 0.4

df_labels_n <- data.frame(
  R   = c(R_pre,  R_reac),
  r   = c(r_pre,  r_reac),
  p   = c(p_pre,  p_reac),
  lab = c("pre-emptive", "reactive")
)

p_equal_f_mat <- 
  matrix(f_val, nrow = length(r_vals), ncol = length(R_vals))

camera <- list(
  eye = list(x = 0.1, y = 0.08, z = 0.1)
)

titlefontsize <- 34
tickfontsize <- 17

fig_pstar_multi <-
  plot_ly() %>%
  add_surface(
    x = R_vals,
    y = r_vals,
    z = p_mat_n_t,
    colorscale = "Viridis",
    showscale = TRUE,
    colorbar = list(
      title = list(
        text = "<i>p</i><sub>thr</sub><sup>(<i>n</i>)</sup>",
        font = list(size = titlefontsize)
      )
    )
  ) %>%
  add_trace(
    data = df_labels_n,
    x = ~R,
    y = ~r,
    z = ~p,
    type = "scatter3d",
    mode = "text",
    text = ~lab,
    textposition = "middle center",
    textfont = list(size = titlefontsize, color = "black"),
    showlegend = FALSE
  ) %>%
  add_surface(
    x = R_vals,
    y = r_vals,
    z = p_equal_f_mat,
    opacity = 0.5,
    showscale = FALSE,
    colorscale = list(c(0, "grey50"), c(1, "grey50")),
    name = "p=f"
  ) %>%
  add_trace(
    x = 100,
    y = 1,
    z = f_val,
    type = "scatter3d",
    mode = "text",
    text = "<i>p</i> = <i>f</i>",
    textfont = list(size = titlefontsize, color = "black"),
    showlegend = FALSE
  ) %>% 
  layout(
    scene = list(
      camera = camera,
      yaxis = list(
        title = "<i>r</i>",
        titlefont = list(size = titlefontsize),
        tickfont = list(size = tickfontsize)),
      xaxis = list(
        title = "<i>R</i> =C<sub>I</sub>/C<sub>V</sub>",
        type  = "log",
        tickvals = c(0.01, 0.1, 1, 10, 100),
        ticktext = c("0.01", "0.1", "1", "10", "100"),
        titlefont = list(size = titlefontsize),
        tickfont = list(size = tickfontsize)
      ),
      zaxis = list(
        title = "<i>p<sub>*</sub></i>", 
        titlefont = list(size = titlefontsize),
        tickfont = list(size = tickfontsize))
    )
  )

fig_pstar_multi
```

#### Heatmap 
$f=0.3$
```{r}
# Parameters
f_val <- 0.3      # capacity fraction
p_val <- 0.6      # mean outbreak probability (not directly used here)

r_vals <- seq(0, 1, length.out = 200)
R_vals <- 10 ^ seq(-2, 2, length.out = 200)

# --- 1. Heatmap data: p_thr^(n) across (R, r) ---
df_heatmap_n <- expand.grid(R = R_vals, r = r_vals) %>%
  mutate(
    p_thr_n = mapply(
      function(R_single, r_single) {
        p_star_multi(R = R_single, r = r_single, f = f_val)
      },
      R, r
    )
  )

# --- 2. Multiple boundary curves for p_thr^(n) ---
p_levels <- seq(0.2, 0.7, by = 0.1)

df_boundary_n <- lapply(p_levels, function(p_target) {
  tmp <- lapply(R_vals, function(RR) {
    f_root <- function(r) p_star_multi(R = RR, r = r, f = f_val) - p_target
    
    sol <- tryCatch(
      uniroot(f_root, interval = c(0, 1)),
      error = function(e) NULL
    )
    
    if (is.null(sol)) return(NULL)
    
    data.frame(
      R        = RR,
      r        = sol$root,
      p_target = p_target
    )
  }) %>% bind_rows()
  
  tmp
}) %>% bind_rows()

# --- 3. Midpoints along each boundary curve for annotation ---
df_boundary_labels <- df_boundary_n %>%
  group_by(p_target) %>%
  slice(round(n() / 2)) %>%
  ungroup() %>%
  mutate(
    label = sprintf("p[thr]^{(n)}==%.1f", p_target)
  )

# --- 4. Region labels (optional) ---
R_pre  <- 10
r_pre  <- 0.2
R_reac <- 10
r_reac <- 0.8

df_labels_n <- data.frame(
  R   = c(R_pre,        R_reac),
  r   = c(r_pre,        r_reac),
  lab = c("pre-emptive", "reactive")
)

# --- 5. Heatmap with multiple boundary lines (all same style) ---
ggplot(df_heatmap_n, aes(x = R, y = r)) +
  # Heatmap
  geom_raster(aes(fill = p_thr_n)) +
  
  # Boundary curves (same color, no legend)
  geom_line(
    data = df_boundary_n,
    aes(x = R, y = r, group = p_target),
    color = "firebrick",
    linewidth = 0.8
  ) +
  
  # Line labels
  geom_text(
    data  = df_boundary_labels,
    aes(x = R, y = r, label = label),
    color = "firebrick",
    size  = 3.5,
    vjust = -0.3,
    parse = TRUE
  ) +
  
  # Region labels
  geom_text(
    data = df_labels_n,
    aes(label = lab),
    color = "white",
    size = 4
  ) +
  
  # Axes
  scale_x_log10(
    breaks = c(0.01, 0.1, 1, 10, 100),
    labels = c("0.01", "0.1", "1", "10", "100"),
    expand = c(0, 0)
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  
  # Colorbar
  scale_fill_viridis_c(
    option = "viridis",
    name = expression(italic(p)[thr]^{(n)})
  ) +
  
  # Axis labels
  labs(
    x = expression("Cost ratio " * italic(R) == italic(C)[I] / italic(C)[V]),
    y = expression("Reactive effectiveness  " * italic(r))
  ) +
  
  theme_minimal() +
  theme(
    panel.grid       = element_blank(),
    axis.title       = element_text(size = 14),
    axis.text        = element_text(size = 12),
    legend.title     = element_text(size = 14),
    legend.text      = element_text(size = 12),
    legend.key.height = unit(1.5, "cm")
  )
```

$f=0.5$
```{r, include=FALSE}
# Parameters
f_val <- 0.5      # capacity fraction
p_val <- 0.6      # mean outbreak probability (not directly used here)

r_vals <- seq(0, 1, length.out = 200)
R_vals <- 10 ^ seq(-2, 2, length.out = 200)

# --- 1. Heatmap data: p_thr^(n) across (R, r) ---
df_heatmap_n <- expand.grid(R = R_vals, r = r_vals) %>%
  mutate(
    p_thr_n = mapply(
      function(R_single, r_single) {
        p_star_multi(R = R_single, r = r_single, f = f_val)
      },
      R, r
    )
  )

# --- 2. Multiple boundary curves for p_thr^(n) ---
p_levels <- seq(0.2, 0.7, by = 0.1)

df_boundary_n <- lapply(p_levels, function(p_target) {
  tmp <- lapply(R_vals, function(RR) {
    f_root <- function(r) p_star_multi(R = RR, r = r, f = f_val) - p_target
    
    sol <- tryCatch(
      uniroot(f_root, interval = c(0, 1)),
      error = function(e) NULL
    )
    
    if (is.null(sol)) return(NULL)
    
    data.frame(
      R        = RR,
      r        = sol$root,
      p_target = p_target
    )
  }) %>% bind_rows()
  
  tmp
}) %>% bind_rows()

# --- 3. Midpoints along each boundary curve for annotation ---
df_boundary_labels <- df_boundary_n %>%
  group_by(p_target) %>%
  slice(round(n() / 2)) %>%
  ungroup() %>%
  mutate(
    label = sprintf("p[thr]^{(n)}==%.1f", p_target)
  )

# --- 4. Region labels (optional) ---
R_pre  <- 10
r_pre  <- 0.2
R_reac <- 10
r_reac <- 0.8

df_labels_n <- data.frame(
  R   = c(R_pre,        R_reac),
  r   = c(r_pre,        r_reac),
  lab = c("pre-emptive", "reactive")
)

# --- 5. Heatmap with multiple boundary lines (all same style) ---
ggplot(df_heatmap_n, aes(x = R, y = r)) +
  # Heatmap
  geom_raster(aes(fill = p_thr_n)) +
  
  # Boundary curves (same color, no legend)
  geom_line(
    data = df_boundary_n,
    aes(x = R, y = r, group = p_target),
    color = "firebrick",
    linewidth = 0.8
  ) +
  
  # Line labels
  geom_text(
    data  = df_boundary_labels,
    aes(x = R, y = r, label = label),
    color = "firebrick",
    size  = 3.5,
    vjust = -0.3,
    parse = TRUE
  ) +
  
  # Region labels
  geom_text(
    data = df_labels_n,
    aes(label = lab),
    color = "white",
    size = 4
  ) +
  
  # Axes
  scale_x_log10(
    breaks = c(0.01, 0.1, 1, 10, 100),
    labels = c("0.01", "0.1", "1", "10", "100"),
    expand = c(0, 0)
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  
  # Colorbar
  scale_fill_viridis_c(
    option = "viridis",
    name = expression(italic(p)[thr]^{(n)})
  ) +
  
  # Axis labels
  labs(
    x = expression("Cost ratio " * italic(R) == italic(C)[I] / italic(C)[V]),
    y = expression("Reactive effectiveness  " * italic(r))
  ) +
  
  theme_minimal() +
  theme(
    panel.grid       = element_blank(),
    axis.title       = element_text(size = 14),
    axis.text        = element_text(size = 12),
    legend.title     = element_text(size = 14),
    legend.text      = element_text(size = 12),
    legend.key.height = unit(1.5, "cm")
  )
```

$R=0.5$
```{r, include=FALSE}
# Parameters
R_val <- 0.5      # capacity fraction
r_vals <- seq(0, 1, length.out = 200)
f_vals <- seq(0, 1, length.out = 200)

# --- 1. Heatmap data: p_thr^(n) across (R, r) ---
df_heatmap_n <- expand.grid(f = f_vals, r = r_vals) %>%
  mutate(
    p_thr_n = mapply(
      function(f_single, r_single) {
        p_star_multi(R = R_val, r = r_single, f = f_single)
      },
      f, r
    )
  )

# --- 2. Multiple boundary curves for p_thr^(n) ---
p_levels <- seq(0.2, 0.7, by = 0.1)

df_boundary_n <- lapply(p_levels, function(p_target) {
  tmp <- lapply(f_vals, function(ff) {
    f_root <- function(r) p_star_multi(R = R_val, r = r, f = ff) - p_target
    
    sol <- tryCatch(
      uniroot(f_root, interval = c(0, 1)),
      error = function(e) NULL
    )
    
    if (is.null(sol)) return(NULL)
    
    data.frame(
      f        = ff,
      r        = sol$root,
      p_target = p_target
    )
  }) %>% bind_rows()
  
  tmp
}) %>% bind_rows()

# # --- 3. Midpoints along each boundary curve for annotation ---
df_boundary_labels <- df_boundary_n %>%
  group_by(p_target) %>%
  slice(round(n() / 2)) %>%
  ungroup() %>%
  mutate(
    label = sprintf("p[thr]^{(n)}==%.1f", p_target)
  )

# --- 4. Region labels (optional) ---
f_pre  <- 0.1
r_pre  <- 0.1
f_reac <- 0.9
r_reac <- 0.9

df_labels_n <- data.frame(
  f   = c(f_pre,        f_reac),
  r   = c(r_pre,        r_reac),
  lab = c("pre-emptive", "reactive")
)

# --- 5. Heatmap with multiple boundary lines (all same style) ---
ggplot(df_heatmap_n, aes(x = f, y = r)) +
  geom_raster(aes(fill = p_thr_n)) +
  # Boundary curves (same color, no legend)
  geom_line(
    data = df_boundary_n,
    aes(x = f, y = r, group = p_target),
    color = "firebrick",
    linewidth = 0.8
  ) +
  geom_text(
    data  = df_boundary_labels,
    aes(x = f, y = r, label = label),
    color = "firebrick",
    size  = 3.5,
    vjust = -0.3,
    parse = TRUE
  ) +
  geom_text(
    data = df_labels_n,
    aes(label = lab),
    color = "white",
    size = 4
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_viridis_c(
    option = "viridis",
    name = expression(italic(p)[thr]^{(italic(n))})
  ) +
  labs(
    x = expression("Vaccinated fraction " * italic(f)),
    y = expression("Reactive effectiveness  " * italic(r))
  ) +
  theme_minimal() +
  theme(
    panel.grid       = element_blank(),
    axis.title       = element_text(size = 14),
    axis.text        = element_text(size = 12),
    legend.title     = element_text(size = 14),
    legend.text      = element_text(size = 12),
    legend.key.height = unit(1.5, "cm")
  )
```

$R=5$
```{r, include=FALSE}
# Parameters
R_val <- 5      # capacity fraction
r_vals <- seq(0, 1, length.out = 200)
f_vals <- seq(0, 1, length.out = 200)

# --- 1. Heatmap data: p_thr^(n) across (R, r) ---
df_heatmap_n <- expand.grid(f = f_vals, r = r_vals) %>%
  mutate(
    p_thr_n = mapply(
      function(f_single, r_single) {
        p_star_multi(R = R_val, r = r_single, f = f_single)
      },
      f, r
    )
  )

# --- 2. Multiple boundary curves for p_thr^(n) ---
p_levels <- seq(0.2, 0.7, by = 0.1)

df_boundary_n <- lapply(p_levels, function(p_target) {
  tmp <- lapply(f_vals, function(ff) {
    f_root <- function(r) p_star_multi(R = R_val, r = r, f = ff) - p_target
    
    sol <- tryCatch(
      uniroot(f_root, interval = c(0, 1)),
      error = function(e) NULL
    )
    
    if (is.null(sol)) return(NULL)
    
    data.frame(
      f        = ff,
      r        = sol$root,
      p_target = p_target
    )
  }) %>% bind_rows()
  
  tmp
}) %>% bind_rows()

# # --- 3. Midpoints along each boundary curve for annotation ---
df_boundary_labels <- df_boundary_n %>%
  group_by(p_target) %>%
  slice(round(n() / 2)) %>%
  ungroup() %>%
  mutate(
    label = sprintf("p[thr]^{(n)}==%.1f", p_target)
  )

# --- 4. Region labels (optional) ---
f_pre  <- 0.1
r_pre  <- 0.1
f_reac <- 0.9
r_reac <- 0.9

df_labels_n <- data.frame(
  f   = c(f_pre,        f_reac),
  r   = c(r_pre,        r_reac),
  lab = c("pre-emptive", "reactive")
)

# --- 5. Heatmap with multiple boundary lines (all same style) ---
ggplot(df_heatmap_n, aes(x = f, y = r)) +
  geom_raster(aes(fill = p_thr_n)) +
  # Boundary curves (same color, no legend)
  geom_line(
    data = df_boundary_n,
    aes(x = f, y = r, group = p_target),
    color = "firebrick",
    linewidth = 0.8
  ) +
  geom_text(
    data  = df_boundary_labels,
    aes(x = f, y = r, label = label),
    color = "firebrick",
    size  = 3.5,
    vjust = -0.3,
    parse = TRUE
  ) +
  geom_text(
    data = df_labels_n,
    aes(label = lab),
    color = "white",
    size = 4
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_viridis_c(
    option = "viridis",
    name = expression(italic(p)[thr]^{(italic(n))})
  ) +
  labs(
    x = expression("Vaccinated fraction " * italic(f)),
    y = expression("Reactive effectiveness  " * italic(r))
  ) +
  theme_minimal() +
  theme(
    panel.grid       = element_blank(),
    axis.title       = element_text(size = 14),
    axis.text        = element_text(size = 12),
    legend.title     = element_text(size = 14),
    legend.text      = element_text(size = 12),
    legend.key.height = unit(1.5, "cm")
  )
```

### Threshold outbreak probability $p_{\mathrm{thr}}^{(n)}$ 

Because $c_{\mathrm{react}}^{(n)}$ is piecewise, $p_{\mathrm{thr}}^{(n)}$ also has a
piecewise form.

#### Case 1: capacity scarce or just sufficient ($f \le p$)

Here the equality occurs in the **reactive-limited regime**, so we set
$$
c_{\mathrm{pre}}^{(n)} = f + (1-f)pR, \qquad
c_{\mathrm{react}}^{(n)} = f + (p - fr)R.
$$

Setting them equal and simplifying: 
$$
p_{\mathrm{thr}}^{(n)} = r.
$$
In this regime, the threshold, $p_{\mathrm{thr}}^{(n)}$ , is independent of $R$: only the relative size of $f$ and $p$ matters.

#### Case 2: capacity abundant ($f \ge p$)

Here the equality occurs in the **reactive-rich** regime, so we set $$
c_{\mathrm{pre}}^{(n)} = f + (1-f)pR, \qquad
c_{\mathrm{react}}^{(n)} = p\bigl[1 + (1-r)R\bigr].
$$

Equating and solving for $p$: 

$$
p_{\mathrm{thr}}^{(n)} = \frac{f}{1 + R(f - r)}.
$$

Consistency with the reactive-rich regime requires $p_{\mathrm{thr}}^{(n)} \le f$,
which holds whenever $f \ge r$ and $R > 0$. 


### Summary 

Putting the two regimes together: 
$$
p_{\mathrm{thr}}^{(n)}(f,r,R)
=
\begin{cases}
r, & f \le r,\\[8pt]
\dfrac{f}{1 + R(f - r)}, & f > r.
\end{cases}
$$

**Interpretation:**

- If $f \le r$, the threshold outbreak probability, $p_{\mathrm{thr}}^{(n)}$, does not depend on $R$ and is simply $r$.
- If $f > r$, the threshold depends on
    the outbreak–to–vaccination cost ratio, $R$:
    - larger $R$ (more costly outbreaks) $\Rightarrow$ smaller
        $p_{\mathrm{thr}}^{(n)}$,
    - larger $f$ (more capacity) $\Rightarrow$ larger $p_{\mathrm{thr}}^{(n)}$, for fixed $R$ and $r$.



```{r econ-demo-data, echo=FALSE}
# Load life expectancy and GDP data
life_exp_data <- 
  as.data.frame(fread("C:/Users/jonghoon.kim/Workspace/myblog/data/cholera_cost/wpp_life_expectancy_20241022.csv"))
# life expectancy at age 25 during 2010-2020, mean age for cholera
life_exp_data %>% 
  filter(Year >= 2010, Year <= 2020, 
         `Region, subregion, country or area *` == "Sub-Saharan Africa") %>% 
  pull(`25`) %>%  
  as.numeric() -> life_exp_25

# Load population by age data 
# prop of under 5 during 2010-2020
age_dist <- 
  as.data.frame(fread("C:/Users/jonghoon.kim/Workspace/myblog/data/cholera_cost/wpp_pop_by_age_20241022.csv"))
age_dist %>% 
  filter(Year >= 2010, Year <= 2020,
         `Region, subregion, country or area *` == "Sub-Saharan Africa") %>% 
  pull(prop_u5) -> prop_U5

# gdp data from World Bank during 2010-2020
gdp_data <- read_xls("C:/Users/jonghoon.kim/Workspace/myblog/data/cholera_cost/GDP_WorldBank.xls")
gdp_data %>% 
  filter(`Country Name` == "Sub-Saharan Africa (IDA & IBRD countries)") %>%
  select(c(`2010`:`2020`)) |> 
  as.numeric() -> gdp_ssa

# workforce data
workforce_data <- read_xls("C:/Users/jonghoon.kim/Workspace/myblog/data/cholera_cost/Workforce_Worldbank.xls")
workforce_data %>% 
  filter(`Country Name` == "Sub-Saharan Africa (excluding high income)")%>%
  select(c(`2010`:`2020`)) |> 
  as.numeric() -> wf_ssa

## Cost-effectiveness parameters

parm <- fread("C:/Users/jonghoon.kim/Workspace/myblog/data/cholera_cost/parameters.csv")
parm <- parm[Disease == "Cholera"]
# GBD data deleted and replaced with Mbewe (2025) Open Forum Infect Dis data
# it is assumed that moderate and severe cases are reported 
parm <- parm[!(Parameter == "Prop_Moderate" & Value == 0.289)]
parm <- parm[!(Parameter == "Prop_Severe" & Value == 0.069)]

# Disease burden parameters
day_ill <- parm[Parameter == "Duration_Illness", Value]
pr_moderate <- parm[Parameter == "Prop_Moderate", Value]
pr_severe <- parm[Parameter == "Prop_Severe", Value]
wt_moderate <- parm[Parameter == "Disability_Weight_Moderate", Value]
wt_severe <- parm[Parameter == "Disability_Weight_Severe", Value]

# Vaccination costs
vacc_price_per_dose <- parm[Parameter == "Vaccine_Cost", Value]
vacc_delivery_cost <- parm[Parameter == "Vaccine_Delivery_Cost", Value]
vacc_shipping_cost <- parm[Parameter == "Vaccine_Shipping_Cost", Value]

# Direct medical costs
patient_cost_hosp <- parm[Parameter == "Patient_Cost_Hosp", Value]
patient_cost_outpt <- parm[Parameter == "Patient_Cost_Outpt", Value]
public_cost_hosp <- parm[Parameter == "Public_Cost_Hosp", Value]
public_cost_outpt <- parm[Parameter == "Public_Cost_Outpt", Value] 

# Productivity costs
patient_workday_lost <- parm[Parameter == "Pt_Workdays_Lost", Value]
caregiver_workday_lost <- parm[Parameter == "Caregiver_Workdays_Lost", Value]
mean_age_inf <- parm[Parameter == "Mean_Age_Infection", Value]

mean_gdp <- mean(gdp_ssa)
mean_remaining_life <- mean(life_exp_25)
mean_cfr <- 0.01 # across countries and year
mean_prop_workforce <- mean(wf_ssa)/100 # across countries and year
pr_tot <- pr_moderate + pr_severe
mean_dis_wt <- wt_moderate * pr_moderate / pr_tot + 
  wt_moderate * pr_severe / pr_tot
```

### Costs

This section uses some parameter values that are not displayed here 

```{r}
N_pop <- 1e6 
dose_per_person <- 1  # Single-dose regimen

# Vaccination costs per person (do not depend on GDP in this setup)
vacc_cost_per_person <- (vacc_price_per_dose + vacc_delivery_cost + vacc_shipping_cost) * dose_per_person

C_vac_per_person <- vacc_cost_per_person

prop_vacc_cov <- 0.9
C_V <- N_pop * prop_vacc_cov * C_vac_per_person

# Function to build cost-ratio df for a given year_val and label
build_cost_df <- function(year_val, scen_label) {
  indirect_coi_per_patient <- (day_ill / 365) * mean_dis_wt * year_val
  
  productivity_lost_per_patient <- 
    mean_prop_workforce * (
      patient_workday_lost / 365 +
      caregiver_workday_lost / 365
    ) * year_val
  
  indirect_cod_per_patient <- 
    mean_cfr * mean_remaining_life * year_val
  
  pr_tot <- pr_moderate + pr_severe 
  
  direct_cost_per_patient <- 
    pr_moderate / pr_tot * (patient_cost_outpt + public_cost_outpt) + 
    pr_severe  / pr_tot * (patient_cost_hosp + public_cost_hosp)
  
  indirect_cost_per_patient <- 
    indirect_coi_per_patient + 
    indirect_cod_per_patient + 
    productivity_lost_per_patient
  
  C_case <- direct_cost_per_patient + indirect_cost_per_patient
  
  # Use strictly positive attack rates for log scale
  attack_rates <- seq(0.001, 0.1, by = 0.001)
  
  tibble(
    attack_rate = attack_rates
  ) |>
    mutate(
      cases   = N_pop * attack_rate,
      C_I     = cases * C_case,
      C_V     = C_V,
      R_ratio = C_I / C_V,
      scenario = scen_label
    )
}

# Build data for GDP and 3x GDP
df_costs_gdp   <- build_cost_df(mean_gdp,        "GDP")
df_costs_3gdp  <- build_cost_df(3 * mean_gdp,    "3 \u00D7 GDP")

df_costs_all <- bind_rows(df_costs_gdp, df_costs_3gdp)

# Plot
ggplot(df_costs_all, 
       aes(x = attack_rate, y = R_ratio, color = scenario)) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = 1, linetype = "dotted") +
  scale_x_log10() +
  labs(
    x = "Fraction of population infected",
    y = expression(italic(R) == italic(C)[I] / italic(C)[V]),
    color = "Year value"
  ) +
  theme_light()
```

## Multiple Populations with Equal Risk, Limited Vaccination Capacity, and A Mixed strategy

We now allow the fixed capacity $f$ to be split between pre-emptive and reactive use.

Let

-   $f_{\mathrm{pre}}$ = fraction of populations vaccinated
    pre-emptively,
-   $f_{\mathrm{react}}$ = capacity available for reactive campaigns as a fraction of population, subject to the capacity constraint

$$
f_{\mathrm{pre}} + f_{\mathrm{react}} = f.
$$

We parameterize by a mixing parameter $\alpha \in [0,1]$:

-   pre-emptive fraction: $f_{\mathrm{pre}} = \alpha f$,
-   reactive fraction: $f_{\mathrm{react}} = (1-\alpha) f$.

$\alpha = 1$ means the pure pre-emptive strategy whereas $\alpha = 0$ means the pure reactive strategy.

### Cost components

The pre-emptive component is straightforward:

-   a fraction $f_{\mathrm{pre}} = \alpha f$ is vaccinated
    pre-emptively, yielding per-population cost

$$
C_{\mathrm{pre\text{-}part}}^{(n)} = f_{\mathrm{pre}} C_{\mathrm{V}} = \alpha f C_{\mathrm{V}}.
$$

The remaining fraction $(1 - f_{\mathrm{pre}}) = (1 - \alpha f)$ is not pre-emptively vaccinated. Among these:

-   each population has outbreak probability $p$;
-   expected number of outbreaks among non-pre-emptive populations is
    $\approx p(1-\alpha f)n$;
-   available reactive campaigns: $f_{\mathrm{react}} n = (1-\alpha)fn$.

Two regimes arise, depending on whether reactive capacity is rich or limited **among non-pre-emptive populations**:

-   Reactive-rich:

$$
f_{\mathrm{react}} \ge p(1 - f_{\mathrm{pre}})
    \quad\Longleftrightarrow\quad
    (1-\alpha)f \ge p(1-\alpha f).
$$

-   Reactive-limited:

$$
f_{\mathrm{react}} < p(1 - f_{\mathrm{pre}})
    \quad\Longleftrightarrow\quad
    (1-\alpha)f < p(1-\alpha f).
$$

#### Regime A: reactive-rich among non-pre-emptive populations

If $(1-\alpha)f \ge p(1-\alpha f)$, then every outbreak in the
non-pre-emptive group can receive a reactive campaign.

For non-pre-emptive populations:

-   with probability $p$: outbreak occurs and is reactively vaccinated,
    cost $C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}$;
-   with probability $(1-p)$: no outbreak, no cost.

Thus the reactive component is

$$
C_{\mathrm{react\text{-}part}}^{(n)}
= (1-\alpha f)\, p\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr).
$$

Total per-population cost for the mixed strategy is:

$$
C_{\mathrm{mixed}}^{(n)}
= \alpha f C_{\mathrm{V}} + (1-\alpha f)\, p\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr).
$$

Normalizing,

$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= \frac{C_{\mathrm{mixed}}^{(n)}}{C_{\mathrm{V}}}
= \alpha f + (1-\alpha f)\, p\bigl[1 + (1-r)R\bigr],
\quad \text{if } (1-\alpha)f \ge p(1-\alpha f).
$$

#### Regime B: reactive-limited among non-pre-emptive populations

If $(1-\alpha)f < p(1-\alpha f)$, there are more outbreaks than
available reactive campaigns in the non-pre-emptive group. The fraction
of such outbreaks that receive a campaign is

$$
q = \frac{f_{\mathrm{react}}}{p(1-f_{\mathrm{pre}})}
= \frac{(1-\alpha)f}{p(1-\alpha f)}.
$$

Among non-pre-emptive populations that experience an outbreak:

-   with probability $q$: cost $C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}$,
-   with probability $1-q$: cost $C_{\mathrm{I}}$.

The reactive component is

$$
\begin{aligned}
C_{\mathrm{react\text{-}part}}^{(n)}
&= (1-f_{\mathrm{pre}})p
\Bigl[
q\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr)
+ (1-q)C_{\mathrm{I}}
\Bigr] \\
&= f_{\mathrm{react}}\bigl(C_{\mathrm{V}} + (1-r)C_{\mathrm{I}}\bigr)
+ \bigl[(1-f_{\mathrm{pre}})p - f_{\mathrm{react}}r \bigr] C_{\mathrm{I}} \\
&= f_{\mathrm{react}} C_{\mathrm{V}}
+ \bigl[(1-f_{\mathrm{pre}})p - f_{\mathrm{react}}r \bigr] C_{\mathrm{I}}.
\end{aligned}
$$

Total per-population cost:

$$
\begin{aligned}
C_{\mathrm{mixed}}^{(n)}
&= f_{\mathrm{pre}} C_{\mathrm{V}} + f_{\mathrm{react}} C_{\mathrm{V}}
+ \bigl[(1-f_{\mathrm{pre}})p - f_{\mathrm{react}}r \bigr] C_{\mathrm{I}}\\
&= f C_{\mathrm{V}} + \bigl[(1-f_{\mathrm{pre}})p - f_{\mathrm{react}}r \bigr] C_{\mathrm{I}}.
\end{aligned}
$$

Substituting $f_{\mathrm{pre}} = \alpha f$,
$f_{\mathrm{react}} = (1-\alpha)f$ and normalizing,

$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= \frac{C_{\mathrm{mixed}}^{(n)}}{C_{\mathrm{V}}}
= f + R\Bigl[(1-\alpha f)p - (1-\alpha)f r \Bigr],
\quad \text{if } (1-\alpha)f < p(1-\alpha f).
$$

An equivalent form is

$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= f + R\Bigl[p - f r + \alpha f(r-p)\Bigr],
\quad \text{if } (1-\alpha)f < p(1-\alpha f),
$$

which makes the linear dependence on $\alpha$ explicit.

$c_{\mathrm{mixed}}^{(n)}(\alpha)$ are affine (linear + constant) in $\alpha$ in both regimes. 

Therefore within each regime, the optimal $\alpha$ is always at the boundary of that regime’s feasible $\alpha$-interval (a corner).
The only other candidate is the switching point where the regime changes (a kink). So the global minimizer, $\alpha^*$ over $\alpha\in[0,1]$ must be in  
$$
\alpha^*\in \{0,\alpha_c,1\},
$$

- Step 1. Find the regime-switch (kink) point $\bar\alpha$
The boundary between regimes is 
$$
(1-\alpha)f = (1-\alpha f)
$$

$$
\alpha_c = \frac{f-p}{f(1-p)}
$$

### Visualization of $c_{\mathrm{mixed}}^{(n)}(\alpha)$ and $\alpha^*$

Functions
```{r}
# Mixed strategy cost c_mix^{(n)}(alpha)
cost_mix_multi <- function(alpha, p, R, r, f) {
  alpha <- pmax(pmin(alpha, 1), 0)

  f_pre   <- alpha * f
  f_react <- (1 - alpha) * f

  cond_rich <- (1 - alpha) * f >= p * (1 - f_pre)

  c_rich <- f_pre + (1 - f_pre) * p * (1 + (1 - r) * R)
  c_lim  <- f + R * ((1 - f_pre) * p - f_react * r)

  ifelse(cond_rich, c_rich, c_lim)
}

opt_alpha_equalrisk <- function(p, R, r, f, grid_len = 1001) {
  alpha_grid <- seq(0, 1, length.out = grid_len)
  costs <- cost_mix_multi(alpha = alpha_grid,
                          p = p, R = R, r = r, f = f)

  idx_min <- which.min(costs)

  list(
    alpha_star = alpha_grid[idx_min],
    cost_star  = costs[idx_min],
    alpha_grid = alpha_grid,
    cost_grid  = costs
  )
}

alpha_star_equalrisk <- function(p, R, r, f, eps = 1e-12) {
  # ensure r is in [0,1]
  r <- pmin(1, pmax(0, r))
  # ---- Scarce capacity: f <= p ----
  if (f <= p + eps) {
    return(
      ifelse(r > p + eps, 0,
      ifelse(r < p - eps, 1, NA_real_))  # NA when r == p (any alpha optimal)
    )
  }
  # ---- Abundant capacity: f > p ----
  alpha_c <- (f - p) / (f * (1 - p))
  alpha_star <- rep(NA_real_, length(r))
  # r < p  -> pure pre-emptive
  alpha_star[r < p - eps] <- 1
  # r > p  -> compare R with R_thr
  idx <- which(r > p + eps)
  if (length(idx) > 0) {
    R_thr <- (1 - p) / (p * pmax(1 - r[idx], eps))  # stabilize near r=1
    alpha_star[idx] <- ifelse(R < R_thr - eps, 0, alpha_c)
  }
  
  alpha_star
}
```
Cost $c_{\mathrm{mixed}}(\alpha)^{(n)}$

```{r}
p <- 0.3
R <- 5
r <- 0.4
f <- 0.5

opt_res <- opt_alpha_equalrisk(p = p, R = R, r = r, f = f,
                           grid_len = 1001)
df <- tibble::tibble(
  alpha = opt_res$alpha_grid,
  cost  = opt_res$cost_grid
)
alpha_star <- opt_res$alpha_star

alpha_star_anal <- alpha_star_equalrisk(p = p, R = R, r = r, f = f, eps = 1e-6)
  
ggplot(df, aes(x = alpha, y = cost)) +
  geom_line(linewidth = 1) +
  geom_vline(
    xintercept = alpha_star,
    linetype   = "dashed",
    color      = "firebrick",
    linewidth  = 0.9
  ) +
  labs(
    title = bquote(italic(p) == .(p) ~ "," ~
                     italic(r) == .(r) ~ "," ~
                     italic(R) == .(R) ~ "," ~
                     italic(f) == .(f)),
    x = expression("Fraction of capacity pre-emptive " ~ italic(alpha)),
    y = expression("Normalized per-population expected cost  " ~ italic(c)[mixed]^(italic(n)))
  ) +
   geom_vline(
    xintercept = alpha_star_anal,
    linetype   = "dotted",
    color      = "firebrick",
    linewidth  = 0.9
  ) +
  annotate(
    "text",
    x     = alpha_star_anal,
    y     = max(df$cost, na.rm = TRUE),
    label = "alpha^'*'",
    parse = TRUE,
    hjust = -0.1,
    vjust = 1.2,
    color = "firebrick",
    size  = 4
  ) +
  theme_light()
```

$\alpha^*$ across $r$
```{r}
R_val <- 5
p_val <- 0.3
f_val <- 0.5

df_alpha <- data.frame(
  r = seq(0, 1, by = 0.001)
)

df_alpha$alpha_star <- alpha_star_equalrisk(
  r = df_alpha$r,
  R = R_val,
  p = p_val,
  f = f_val
)

# Reference value of alpha_c
alpha_c <- ifelse(f_val > p_val, (f_val - p_val) / (f_val * (1 - p_val)), NA_real_)

# df_alpha[is.na(df_alpha$alpha_star),]$alpha_star <- 1
  
ggplot(df_alpha, aes(x = r, y = alpha_star)) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  geom_hline(yintercept = 1, linetype = "dotted") +
  geom_vline(xintercept = p_val, linetype = "dashed") +
  geom_hline(yintercept = alpha_c, linetype = "dashed") +
  coord_cartesian(ylim = c(0, 1)) +
  labs(
    x = expression("Reactive effectiveness "~italic(r)),
    y = expression("Optimal pre-emptive fraction "~italic(alpha)^"*"),
    title =bquote(italic(p) == .(p_val) ~ "," ~
                     italic(R) == .(R_val) ~ "," ~
                     italic(f) == .(f_val))) +
  theme_light()
```

3d surface of $\alpha^*(R,r)$:

```{r}
titlefontsize <- 34
tickfontsize <- 17

p_val <- 0.3
f_val <- 0.6

r_vals <- seq(0, 1, length.out = 100)
R_vals <- 10 ^ seq(-2, 2, length.out = 100)

alpha_mat <- outer(
  R_vals, r_vals,
  Vectorize(function(R, r) {
    opt_alpha_equalrisk(
      p = p_val,
      R = R,
      r = r,
      f = f_val,
      grid_len = 301
    )$alpha_star
  })
)

alpha_mat_t <- t(alpha_mat)

camera <- list(
  eye = list(x = 0.1, y = 0.08, z = 0.1)
)

fig_alpha_surface <-
  plot_ly() %>%
  add_surface(
    x = R_vals,
    y = r_vals,
    z = alpha_mat_t,
    colorscale = "Viridis",
    showscale = TRUE,
    colorbar = list(
      title = list(
        text = "<i>α</i><sup>*</sup>",
        font = list(size = titlefontsize)
      )
    )
  ) %>%
  layout(
    scene = list(
      camera = camera,
      yaxis = list(
        title = "<i>r</i>",
        titlefont = list(size = titlefontsize),
        tickfont = list(size = tickfontsize)),
      xaxis = list(
        title    = "<i>R</i> = C<sub>I</sub> / C<sub>V</sub>",
        titlefont = list(size = titlefontsize),
        tickfont = list(size = tickfontsize),
        type     = "log",
        tickvals = c(0.01, 0.1, 1, 10, 100),
        ticktext = c("0.01", "0.1", "1", "10", "100")
      ),
      zaxis = list(
        title = "<i>α</i><sup>*</sup>",
        titlefont = list(size = titlefontsize),
        tickfont = list(size = tickfontsize)
      )
    )
  )

fig_alpha_surface
```

### Optimal allocation Strategy ($\alpha^*$)

Let $\alpha^*$ denote the optimal fraction of vaccine capacity $f$
allocated to pre-emptive vaccination. The optimal strategy depends
on whether vaccine capacity is scarce ($f \le p$) or abundant ($f > p$).

#### 1. Scarce capacity ($f \le p$)

When capacity is insufficient to cover the expected outbreak size, the
strategy is a simple corner solution determined entirely by the reactive
effectiveness $r$:

$$
\alpha^* =
\begin{cases}
0 \quad (\text{pure reactive}), & \text{if } r > p \\
1 \quad (\text{pure pre-emptive}), & \text{if } r < p \\
\text{any } \alpha \in [0,1], & \text{if } r = p
\end{cases}
$$

#### 2. Abundant Capacity ($f > p$)

When capacity exceeds the expected outbreak size, the optimal strategy
depends on the cost ratio $R$ relative to the threshold $R_{\mathrm{thr}}$:

$$
\alpha^* =
\begin{cases}
1 \quad (\text{pure pre-emptive}), & \text{if } r < p \\
0 \quad (\text{pure reactive}), & \text{if } r > p \text{ and } R < R_{\mathrm{thr}} \\
\frac{f - p}{1 - p} \quad (\text{mixed strategy}), & \text{if } r > p \text{ and } R \ge R_{\mathrm{thr}}
\end{cases}
$$
where
$$
R_{\mathrm{thr}} = \frac{1-p}{p(1-r)}
$$
> **Note:** In the abundant regime with high outbreak costs
> ($R \ge R_{\mathrm{thr}}$), the mixed strategy $\alpha^* = \frac{f - p}{f(1 - p)}$
> ensures that pre-emptive vaccination is maximized just enough so that
> the remaining capacity can fully cover the remaining risk reactively.

The quantity, $\alpha_{\mathrm{c}}$, is not chosen by minimizing a smooth function. Instead, it arises from a feasibility constraint: it is the largest fraction of capacity that can be allocated to pre-emptive vaccination without creating a shortfall in reactive response among the remaining populations. The denominator, $1 - p$, may be interpreted as the fraction of non-outbreak populations and the numerator, $(f-p)/f$, refers to the fraction of $f$ of resources that may be left after covering all outbreak populations. $R_{\mathrm{thr}}$ is the outbreak cost ratio at which the expected cost of relying on reactive vaccination (denominator, $p(1-r)$) equals the cost of vaccinating pre-emptively (numerator, $1-p$).

## Multiple Populations with Heterogeneous Outbreak Risk

We extend the equal-risk $n$-population model to allow heterogeneous
outbreak probabilities across populations and to incorporate
targeting accuracy for pre-emptive vaccination. 

The pre-emptive and reactive fractions satisfy
$$
f_{\mathrm{pre}} + f_{\mathrm{react}} = f.
$$

### Exponential hazard model

Assume each population has a latent outbreak hazard

$$
\Lambda_i \sim \mathrm{Exponential}(\theta), \qquad \theta > 0.
$$

The outbreak probability for population $i$ is
$$
p_i = 1 - e^{-\Lambda_i}, \qquad p_i \in (0,1).
$$

Using the transformation $p = 1 - e^{-\lambda}$, we obtain the density
$$
f_P(p) = \theta (1-p)^{\theta - 1}, \qquad 0 < p < 1,
$$ so the outbreak-probability random variable
$$
P \sim \mathrm{Beta}(1,\theta).
$$

Key properties:

-   Mean outbreak probability
    $$
    p_{\mathrm{mean}} = \mathbb{E}[P] = \frac{1}{1+\theta}.
    $$

-   If $\theta < 1$: mass is concentrated near $p = 1$ (many high-risk
    populations).

-   If $\theta = 1$: $P \sim \mathrm{Uniform}(0,1)$.

-   If $\theta > 1$: risks are skewed toward 0.

We treat $p_i$ as i.i.d. draws from $\mathrm{Beta}(1,\theta)$.

### Tail selection under perfect targeting ($\rho=1$)

Under perfect ranking, populations can be ordered by their outbreak
probabilities $p_i$ from highest to lowest.

Suppose a fraction 
$$
q = f_{\mathrm{pre}} = \alpha f
$$ 
of populations is vaccinated pre-emptively. This corresponds to vaccinating the top $q$ fraction of the risk distribution.


### Risk cutoff associated with vaccinating fraction $q$

Define the cutoff $p_{\mathrm{cut}}(q)$ as the unique value satisfying
$$
\Pr(P \ge p_{\mathrm{cut}}(q)) = q.
$$
$p_{\mathrm{cut}}(q)$ is the minimum outbreak probability required to
be included among the top $q$ populations. It is a deterministic function of $q$.

For $P \sim \mathrm{Beta}(1,\theta)$,

$$
\Pr(P \ge t) = (1-t)^\theta.
$$

Thus,
$$
q = (1 - p_{\mathrm{cut}}(q))^\theta
\quad\Longrightarrow\quad
p_{\mathrm{cut}}(q) = 1 - q^{1/\theta}.
$$

### Mean outbreak probability in the pre-emptive (top-risk) group

Define
$$
p_{\mathrm{pre}}(q) = \mathbb{E}[P \mid P \ge p_{\mathrm{cut}}(q)].
$$

Direct calculation yields
$$
p_{\mathrm{pre}}(q)
= 1 - \frac{\theta}{\theta + 1}\, q^{1/\theta},
\qquad 0 < q \le 1.
$$

Checks:

-   If $q = 1$:
    $$
    p_{\mathrm{pre}}(1) = \frac{1}{1+\theta} = p_{\mathrm{mean}}.
    $$

-   As $q \to 0$:
    $$
    p_{\mathrm{pre}}(q) \to 1.
    $$

### Mean outbreak probability in the remaining group

Let
$$
p_{\mathrm{rem}}(q) = \mathbb{E}[P \mid P < p_{\mathrm{cut}}(q)].
$$

Using the law of total expectation:
$$
p_{\mathrm{mean}}
= q\,p_{\mathrm{pre}}(q)
+ (1-q)\,p_{\mathrm{rem}}(q),
$$ 
so

$$
p_{\mathrm{rem}}(q)
= \frac{p_{\mathrm{mean}} - q\,p_{\mathrm{pre}}(q)}{1-q}.
$$

Substituting $p_{\mathrm{mean}} = 1/(\theta+1)$ and the expression above
for $p_{\mathrm{pre}}(q)$ gives

$$
p_{\mathrm{rem}}(q)
= 
\frac{
\dfrac{1}{\theta+1}
- q 
+ \dfrac{\theta}{\theta+1} q^{1 + 1/\theta}
}{1 - q}.
$$

Using $q = f_{\mathrm{pre}} = \alpha f$, we write
$$
p_{\mathrm{pre}}(\alpha f)
= 1 - \frac{\theta}{\theta+1}(\alpha f)^{1/\theta},
$$ 

$$
p_{\mathrm{rem}}(\alpha f)
=
\frac{
\dfrac{1}{\theta+1}
- \alpha f
+ \dfrac{\theta}{\theta+1} (\alpha f)^{1 + 1/\theta}
}
{1 - \alpha f}.
$$

### Mixed-strategy cost

#### Pre-emptive group

Normalized expected cost:

$$
c_{\mathrm{pre}}^{(n)}(\alpha) = f_{\mathrm{pre}} = \alpha f.
$$

#### Remaining group

Fraction:

$$
1 - f_{\mathrm{pre}} = 1 - \alpha f.
$$

Mean outbreak probability:

$$
p' = p_{\mathrm{rem}}(\alpha f).
$$

Reactive capacity:
$$
f_{\mathrm{react}} = (1-\alpha)f.
$$

Effective capacity per remaining population:
$$
f' = \frac{f_{\mathrm{react}}}{1 - f_{\mathrm{pre}}}
= \frac{(1-\alpha)f}{1 - \alpha f}.
$$

### Reactive-limited remaining group ($f' < p'$)

$$
c_{\mathrm{rem}}^{(n)}(p',f')
= f' + \bigl(p' - fr' \bigr)R.
$$

Total cost:
$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= f + R\Bigl[(1-\alpha f)p' - (1-\alpha)f r \Bigr].
$$

### Reactive-rich remaining group ($f' \ge p'$)

$$
c_{\mathrm{rem}}^{(n)}(p',f')
= p'\,\bigl[1 + (1-r)R\bigr].
$$

$$
c_{\mathrm{mixed}}^{(n)}(\alpha)
= 
\alpha f
+ (1-\alpha f)\,p'\,\bigl[1 + (1-r)R\bigr].
$$

Unlike the equal-risk case, $p'$ is nonlinear, so
$c_{\mathrm{mixed}}^{(n)}(\alpha)$ is not piecewise-linear, and no
closed-form optimal $\alpha^*$ exists.

We therefore compute $\alpha^*$ by 1D minimization: 
$$
\alpha^* = 
\arg\min_{\alpha\in[0,1]} c_{\mathrm{mixed}}^{(n)}(\alpha).
$$


## Imperfect Targeting 

We model imperfect targeting using a noisy prioritization score, such
that the targeting parameter $\rho$ retains its literal interpretation as a rank correlation between true outbreak risk and the score used for prioritization. We allocate a fraction $q=\alpha f$ of total capacity to pre-emptive vaccination and reserve the remainder $(1-\alpha)f$ for reactive campaigns. Under heterogeneous risk and imperfect targeting, the pre-emptively vaccinated set is defined by ranking populations by a noisy score $S=\Lambda+\varepsilon$ that has Spearman's rank correlation $\rho$ with the true hazard $\Lambda$. This induces an $\alpha$-dependent remaining-group mean outbreak probability $p' = p_{\mathrm{rem}}(\alpha f,\rho)$, which is generally nonlinear in $\alpha$. Conditional on $p'$, the remaining group behaves like an equal-risk subproblem with effective reactive capacity $f'=(1-\alpha)f/(1-\alpha f)$, yielding reactive-rich and reactive-limited regimes depending on whether $f'\ge p'$ or $f'<p'$. Because $p'$ varies with $\alpha$, the mixed-strategy cost $c_{\mathrm{mix}}^{(n)}(\alpha)$ is not affine, so $\alpha^*$ is obtained by one-dimensional numerical minimization.

### Latent outbreak risk

Each population $i$ has a latent outbreak hazard

$$
\Lambda_i \sim \mathrm{Exponential}(\theta), \qquad \theta > 0.
$$

The outbreak probability for population $i$ is

$$
P_i = 1 - e^{-\Lambda_i}, \qquad P_i \in (0,1).
$$

Marginally,

$$
P \sim \mathrm{Beta}(1,\theta),
$$

with mean outbreak probability

$$
p_{\mathrm{mean}} = \mathbb{E}[P] = \frac{1}{1+\theta}.
$$

Because $P$ is a strictly increasing function of $\Lambda$, ranking
populations by $P$ or by $\Lambda$ is equivalent.

### Noisy prioritization score and definition of $\rho$

True outbreak risk is not directly observed. Instead, populations are
ranked according to a noisy score

$$
S_i = \Lambda_i + \varepsilon_i,
$$

where

$$
\varepsilon_i \stackrel{i.i.d.}{\sim} \mathcal{N}(0,\sigma^2),
\qquad
\varepsilon_i \perp \Lambda_i.
$$
Targeting accuracy is defined as the rank correlation

$$
\rho \equiv \mathrm{corr}_{\mathrm{rank}}(\Lambda, S),
$$

where $\mathrm{corr}_{\mathrm{rank}}(\cdot,\cdot)$ denotes Spearman’s
rank correlation.

- $\sigma = 0$ implies $\rho = 1$ (perfect ranking).
- $\sigma \to \infty$ implies $\rho = 0$ (random ranking).

For exponential $\Lambda$ and additive Gaussian noise, the mapping
$\sigma \mapsto \rho$ is monotone but does not admit a closed-form
expression. In practice, $\sigma(\rho)$ is obtained numerically and
treated as known.

### Selection rule for pre-emptive vaccination

Let

$$
q = f_{\mathrm{pre}} = \alpha f
$$

denote the fraction of populations vaccinated pre-emptively.

Populations are ranked by the score $S$, and the pre-emptive group
consists of those satisfying

$$
S \ge s_{\mathrm{cut}}(q),
$$

where the score cutoff $s_{\mathrm{cut}}(q)$ is defined implicitly by

$$
\Pr(S \ge s_{\mathrm{cut}}(q)) = q.
$$

Since $S = \Lambda + \varepsilon$, we have

$$
\Pr(S \ge s)
=
\mathbb{E}\!\left[
1 - \Phi\!\left(\frac{s-\Lambda}{\sigma}\right)
\right],
\qquad
\Lambda \sim \mathrm{Exponential}(\theta),
$$

where $\Phi(\cdot)$ denotes the standard normal CDF. The cutoff
$s_{\mathrm{cut}}(q)$ is obtained by solving this equation for a given $q$.

### Mean outbreak probability in the pre-emptive group

The mean outbreak probability among pre-emptively vaccinated
populations is

$$
p_{\mathrm{pre}}(q,\sigma)
=
\mathbb{E}[P \mid S \ge s_{\mathrm{cut}}(q)]
=
\mathbb{E}[1 - e^{-\Lambda} \mid S \ge s_{\mathrm{cut}}(q)].
$$

Using Bayes’ rule, this can be written as

$$
p_{\mathrm{pre}}(q,\sigma)
=
\frac{
\mathbb{E}\!\left[
(1 - e^{-\Lambda})
\left\{
1 - \Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right\}
\right]
}{
\mathbb{E}\!\left[
1 - \Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right]
}.
$$

By construction, the denominator equals $q$, so

$$
p_{\mathrm{pre}}(q,\sigma)
=
\frac{1}{q}
\mathbb{E}\!\left[
(1 - e^{-\Lambda})
\left\{
1 - \Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right\}
\right].
$$

### Mean outbreak probability in the remaining group

The mean outbreak probability among the remaining populations is

$$
p_{\mathrm{rem}}(q,\sigma)
=
\mathbb{E}[P \mid S < s_{\mathrm{cut}}(q)].
$$

Equivalently,

$$
p_{\mathrm{rem}}(q,\sigma)
=
\frac{1}{1-q}
\mathbb{E}\!\left[
(1 - e^{-\Lambda})
\Phi\!\left(\frac{s_{\mathrm{cut}}(q)-\Lambda}{\sigma}\right)
\right].
$$

By construction, the overall mean is preserved:

$$
q\,p_{\mathrm{pre}}(q,\sigma)
+
(1-q)\,p_{\mathrm{rem}}(q,\sigma)
=
p_{\mathrm{mean}}.
$$

#### Effective Reactive Capacity

Among the remaining fraction $1-q = 1-\alpha f$ of populations:

$$
f_{\mathrm{react}} = (1-\alpha)f,
\qquad
f' = \frac{f_{\mathrm{react}}}{1-q}
= \frac{(1-\alpha)f}{1-\alpha f}.
$$

The remaining group behaves like an equal-risk subproblem with outbreak
probability $p'$ and effective capacity $f'$.

## Step 5: Remaining-Group Cost Regimes

Two regimes arise:

### Reactive-rich remaining group ($f' \ge p'$)

$$
c_{\mathrm{rem,per}} = p'\,[1 + (1-r)R].
$$

### Reactive-limited remaining group ($f' < p'$)

$$
c_{\mathrm{rem,per}} = f' + (p' - f'r)R.
$$

#### Total Mixed-Strategy Cost

The normalized expected cost per population is
$$
c_{\mathrm{mix}}^{(n)}(\alpha)
= q + (1-q)\,c_{\mathrm{rem,per}},
$$
where $q = \alpha f$.

Because $p'$ varies with $\alpha$, the function
$c_{\mathrm{mix}}^{(n)}(\alpha)$ is generally **nonlinear**, unlike the
piecewise-linear form in the equal-risk model.

#### Determination of the Optimal Pre-emptive Fraction

The optimal allocation is obtained by one-dimensional minimization:
$$
\alpha^*
=
\arg\min_{\alpha \in [0,1]}
c_{\mathrm{mix}}^{(n)}(\alpha).
$$

This replaces the closed-form corner/kink solution available in the
equal-risk case.

### Visualization 

#### Core simulation utilities
```{r}
# ---- Utility: simulate Lambda and convert to P ----

sim_lambda_P <- function(M, theta, seed = 1) {
 set.seed(seed)
 lambda <- rexp(M, rate = theta)         # Lambda ~ Exp(theta)
 P <- 1 - exp(-lambda)                   # P = 1 - exp(-Lambda)
 list(lambda = lambda, P = P)
}

# ---- Given sigma, compute Spearman rank correlation between Lambda and S ----

spearman_rho_given_sigma <- function(lambda, sigma, seed = 1) {
 set.seed(seed)
 S <- lambda + rnorm(length(lambda), mean = 0, sd = sigma)
 suppressWarnings(cor(lambda, S, method = "spearman"))
}

# ---- Calibrate sigma so that Spearman cor(Lambda, S) ~= rho_target ----

calibrate_sigma_for_rho <- function(lambda, rho_target,
sigma_hi = 50, seed = 1) {

 # monotone: rho decreases as sigma increases
 f_obj <- function(log_sigma) {
  sigma <- exp(log_sigma)
  rho_hat <- spearman_rho_given_sigma(lambda, sigma, seed = seed)
  rho_hat - rho_target
 }

 # bracket in log-space
  
 lo <- log(1e-6)
 hi <- log(sigma_hi)
  
 # ensure bracket contains root
  
 f_lo <- f_obj(lo)
 f_hi <- f_obj(hi)
 if (f_lo < 0) return(0)        # already below target even at tiny sigma
 if (f_hi > 0) return(exp(hi))  # still above target even at huge sigma
  
 uniroot(f_obj, lower = lo, upper = hi)$root |> exp()
}

# ---- Given q, compute score cutoff s_cut so that Pr(S >= s_cut) = q ----

score_cutoff <- function(S, q) {
 # top q => (1-q) quantile
 as.numeric(stats::quantile(S, probs = 1 - q, names = FALSE, type = 7))
}

# ---- Estimate p_pre and p_rem by Monte Carlo under calibrated sigma ----

estimate_pre_rem_means <- function(lambda, P, sigma, q, seed = 1) {
 set.seed(seed)
 S <- lambda + rnorm(length(lambda), mean = 0, sd = sigma)
  
  if (q <= 0) {
    return(list(p_pre = NA_real_, p_rem = mean(P)))
  }
  if (q >= 1) {
    return(list(p_pre = mean(P), p_rem = NA_real_))
  }
  
  s_cut <- score_cutoff(S, q = q)
  sel <- S >= s_cut
  
  p_pre <- mean(P[sel])
  p_rem <- mean(P[!sel])
  
  list(p_pre = p_pre, p_rem = p_rem, s_cut = s_cut)
}

```

#### Mixed cost and optimization over $\alpha$
```{r}
# ---- Mixed-strategy cost under Option 2 ----
cost_mix_heterorisk <- function(alpha, f, r, R, theta, rho,
                          lambda, P, seed_sigma = 1, seed_score = 2,
                          sigma_cache = NULL) {

  alpha <- max(0, min(1, alpha))
  q <- alpha * f

  # calibrate sigma if not provided

  sigma <- if (is.null(sigma_cache)) {
    calibrate_sigma_for_rho(lambda, rho_target = rho, 
                            seed = seed_sigma)
  } else {
    sigma_cache
  }

  # estimate remaining mean risk p' = p_rem(q, rho)
  
  pre_rem <- estimate_pre_rem_means(lambda, P, sigma = sigma, q = q, seed = seed_score)
  p_prime <- pre_rem$p_rem
  
  # effective reactive capacity among remaining group
  
  frac_rem <- 1 - q
  f_react <- (1 - alpha) * f
  f_prime <- f_react / frac_rem
  
  # pre-emptive cost (normalized by C_V)
  
  c_pre <- q

  # remaining-group per-pop cost (same two regimes as equal-risk subproblem)
  
  if (f_prime < p_prime) {
    c_rem_per <- f_prime + (p_prime - f_prime * r) * R
  } else {
    c_rem_per <- p_prime * (1 + (1 - r) * R)
  }
  
    c_pre + frac_rem * c_rem_per
  }

# ---- Grid-search for alpha* ----

opt_alpha_heterorisk <- function(f, r, R, theta, rho,
  lambda, P,
  grid_len = 501,
  seed_sigma = 1, seed_score = 2) {
  
  # calibrate sigma once per scenario for speed/consistency
  
  sigma <- calibrate_sigma_for_rho(lambda, rho_target = rho, seed = seed_sigma)
  
  alpha_grid <- seq(0, 1, length.out = grid_len)
  cost_grid <- sapply(alpha_grid, function(a) {
    cost_mix_heterorisk(a, f=f, r=r, R=R, theta=theta, rho=rho,
                  lambda=lambda, P=P, seed_sigma = seed_sigma,
                  seed_score = seed_score, sigma_cache = sigma)
  })
  
  idx <- which.min(cost_grid)
  
  list(alpha_star = alpha_grid[idx],
  cost_star  = cost_grid[idx],
  alpha_grid = alpha_grid,
  cost_grid  = cost_grid,
  sigma      = sigma)
}

```

Plot 1 — cost profile $c_{\mathrm{mix}}^{(n)}(\alpha)$ with $\alpha^*$

```{r}
# ---- choose one scenario ----
f_val    <- 0.5
r_val    <- 0.4
R_val    <- 5
p_mean   <- 0.3
theta    <- 1 / p_mean - 1
rho_val  <- 0.6

# ---- simulate latent risks once (large M helps smooth curves) ----
M <- 1000
# M <- 200000
sim <- sim_lambda_P(M = M, theta = theta, seed = 1)
lambda <- sim$lambda
P      <- sim$P

opt <- opt_alpha_heterorisk(f=f_val, r=r_val, R=R_val, 
                            theta=theta, rho=rho_val,
                            lambda=lambda, P=P,
                            grid_len = 401)

df <- data.frame(alpha = opt$alpha_grid, cost = opt$cost_grid)
alpha_star <- opt$alpha_star

ggplot(df, aes(x = alpha, y = cost)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = alpha_star,
  linetype = "dashed", color = "firebrick", linewidth = 0.9) +
  labs(
  title = bquote(italic(p)[mean]==.(p_mean)~","~
    italic(r)==.(r_val)~","~
    italic(R)==.(R_val)~","~
    italic(f)==.(f_val)~","~
    italic(rho)==.(rho_val)),
  x = expression("Fraction of capacity pre-emptive " ~ italic(alpha)),
  y = expression("Normalized per-population expected cost " ~ italic(c)[mix]^(italic(n)))
) +
theme_light()
```

Plot 2 — $\alpha^*$ vs $r$ (fixed $R,f,p_{\mathrm{mean}},\rho$)
```{r}
r_grid <- seq(0, 1, by = 0.05)

alpha_star_vec <- sapply(r_grid, function(r_i) {
  opt_alpha_heterorisk(f=f_val, r=r_i, R=R_val,
                    theta=theta, rho=rho_val,
                    lambda=lambda, P=P,
                    grid_len = 301)$alpha_star
})

df_ar <- data.frame(r = r_grid, alpha_star = alpha_star_vec)

ggplot(df_ar, aes(x = r, y = alpha_star)) +
  geom_line(linewidth = 1) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(
    title = bquote(italic(p)[mean]==.(p_mean)~","~
                     italic(R)==.(R_val)~","~
                     italic(f)==.(f_val)~","~
                     italic(rho)==.(rho_val)),
    x = expression("Reactive effectiveness " ~ italic(r)),
    y = expression("Optimal pre-emptive fraction " ~
                     italic(alpha)^"*")) +
  theme_light()
```

Plot 3 — Heatmap of $\alpha^*(R,r)$ (fixed $f,p_{\mathrm{mean}},\rho$)

```{r}
r_vals <- seq(0, 1, length.out = 20)
R_vals <- 10 ^ seq(-2, 2, length.out = 20)

grid <- expand.grid(r = r_vals, R = R_vals)

grid$alpha_star <- mapply(function(r_i, R_i) {
  opt_alpha_heterorisk(f=f_val, r=r_i, R=R_i,
                     theta=theta, rho=rho_val,
                     lambda=lambda, P=P,
                     grid_len = 201)$alpha_star}, grid$R, grid$r)

ggplot(grid, aes(x = r, y = R, fill = alpha_star)) +
  geom_tile() +
  scale_y_log10() +
    # Colorbar
  scale_fill_viridis_c(
    option = "viridis",
    name = expression(italic(alpha)^"*")
  ) +
  labs(
    title = bquote(italic(p)[mean]==.(p_mean)~","~
      italic(f)==.(f_val)~","~
      italic(rho)==.(rho_val)),
    x = expression(italic(r)),
    y = expression(italic(R)),
    fill = expression(italic(alpha)^"*")
  ) +
  theme_light()

```

Plot 4 — $\alpha^*$ vs $\rho$

```{r}
f_val    <- 0.5
r_val    <- 0.6
R_val    <- 20
p_mean   <- 0.3
theta    <- 1 / p_mean - 1

# ---- Simulate latent risks once ----
# M <- 200000
M <- 1000
sim <- sim_lambda_P(M = M, theta = theta, seed = 1)
lambda <- sim$lambda
P      <- sim$P

# ---- Compute alpha* across rho ----
rho_grid <- seq(0, 1, by = 0.05)

alpha_star_vec <- sapply(rho_grid, function(rho_i) {
  opt_alpha_heterorisk(f=f_val, r=r_val, R=R_val, theta=theta,
                       rho=rho_i, lambda=lambda, P=P, 
                       grid_len = 401)$alpha_star
})

df_rho <- data.frame(rho = rho_grid, alpha_star = alpha_star_vec)

# ---- Plot ----
ggplot(df_rho, aes(x = rho, y = alpha_star)) +
  geom_line(linewidth = 1) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(
    title = bquote(italic(p)[mean]==.(p_mean)~","~
                   italic(r)==.(r_val)~","~
                   italic(R)==.(R_val)~","~
                   italic(f)==.(f_val)),
    x = expression("Targeting accuracy (Spearman rank correlation) " ~ italic(rho)),
    y = expression("Optimal pre-emptive fraction " ~ italic(alpha)^"*")
  ) +
  theme_light()
```

Plot 5 — $c_{\mathrm{mix}}^{(n)}$, $\alpha^*$ vs $\rho$

```{r}
f_val    <- 0.5
r_val    <- 0.4
R_val    <- 5
p_mean   <- 0.3
theta    <- 1 / p_mean - 1
rho_vals <- c(0.2, 0.6, 1.0)   # <- three facets (edit as you like)

# ---- simulate latent risks once (keep fixed across rho for fair comparison) ----

M <- 1000
# M <- 200000
sim <- sim_lambda_P(M = M, theta = theta, seed = 1)
lambda <- sim$lambda
P      <- sim$P

# ---- compute cost profile for each rho ----

df_all <- purrr::map_dfr(rho_vals, function(rho_val) {

  opt <- opt_alpha_heterorisk(
    f      = f_val,
    r      = r_val,
    R      = R_val,
    theta  = theta,
    rho    = rho_val,
    lambda = lambda,
    P      = P,
    grid_len = 401
  )

  data.frame(
    alpha      = opt$alpha_grid,
    cost       = opt$cost_grid,
    rho        = rho_val,
    alpha_star = opt$alpha_star
    )
})

# ---- one vline per facet ----

df_vline <- df_all |>
  distinct(rho, alpha_star) |>
  mutate(
    rho_lab = factor(
      rho,
      levels = rho_vals,
      labels = paste0("italic(rho)==", rho_vals)
    )
  )

# ---- facet labels ----
df_all <- df_all |>
  mutate(
    rho_lab = factor(
      rho,
      levels = rho_vals,
      labels = paste0("italic(rho)==", rho_vals)
    )
  )

# ---- plot ----
ggplot(df_all, aes(x = alpha, y = cost)) +
  geom_line(linewidth = 1) +
  geom_vline(
    data = df_vline,
    aes(xintercept = alpha_star),
    linetype = "dashed",
    color = "firebrick",
    linewidth = 0.9
  ) +
  facet_wrap(~ rho_lab, labeller = label_parsed) +
  labs(
    title = bquote(
      italic(p)[mean]==.(p_mean)~","~
      italic(r)==.(r_val)~","~
      italic(R)==.(R_val)~","~
      italic(f)==.(f_val)
    ),
    x = expression("Fraction of capacity pre-emptive " ~ italic(alpha)),
    y = expression("Normalized per-population expected cost " ~ 
                     italic(c)[mix]^(italic(n)))
  ) +
  theme_light()

```


## References
